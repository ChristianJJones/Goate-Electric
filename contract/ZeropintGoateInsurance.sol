this is my current setup for Goat Electric; using digital utilites to change the way we use digital assets; keep the code and everything the same; just revise and edit what needs to be already and then the stuff i tell you to change.
for the homepage:
in the border it should be the logo picture and then THE LAMBDUCK, INC. (instead of Goate Electric); and then a little over to the right should be the SignUp/Login button; once theyve did the kyc/aml then the button should change to their logged in username and shift over; to the right of the button should be the connect device button that gets, syncs, and uses oracles to retrieve/track, and store device information. and the settings button
change the balances to be 1. Zeroppoint $ZPE, 2. ZeropointWifi $ZPW, 3, $ZeropointPhoneService $ZPP, 4. ZerpointDigitalStockNFT, 5. TheGoateToken $GOATE, 6. GresyStx $GySt, 7. GerastyxPropertyNFT, 8. ZeropointGoateInsurance $ZGI, 9. S.H.I.E.L.D. Mode $SDM surrounding $USD in a circle; have it show their balances and then when they click it then they are given the option to interact with it; wether buy, sell, swap, transfer, consume ( if it is able to be consumed); and then in modules a little further down below the balances:

take the navigation tabs and turn them into modals and buttons inside of them.
3x3 modals. 3 by 3 boxes.
when people create their account; generate addresses for them and map those addresses to their username/phone number/ email address they signed up with, and when the login they can access and manage their assets within the wallet too; even if they receive funds from external addresses and chains. the wallets will be able to direct them to the correct wallet or send them back with it's quantum HackProof Defense and Systems
Every contract & page should be made using the USDMediator, InstilledInteroperability, and the Unreal Engine; 

*logo* {refreshes and goes to the home page when clicked}
Goate Electric {refreshes the page when clicked}
{$username} { refreshes the page when clicked }
[deviceConnected] { gets, syncs, and uses oracles to connect to a person's device and stores it's information in the device manager
(settings){ is the kyc/aml information and update buttons, TheLambduckCard.sol information with freeze and regenerate buttons, connect bank, connect card with disconnect options, And deposit and withdraw}





[header: Goate Electric
description: Digital Utilities ]{
once clicked take them to the home page:
includes: USDMediator, InstilledInteroperability, Zeropoint, ZeropointWIfi, ZeropointPhoneServices, ZeropointHolographicVision, ZeropointDIgitalStockNFT, ZeropointGoateInsurance, GerastyxPropertyNFT, S.H.I.E.L.D. Mode,

}, 

[header: Device Manager
description: Engage Your Way]{
once clicked take them to the manage devices page:
includes: USDMediator, InstilledInteroperability, Zeropoint, ZeropointWifi, ZeropointPhoneService, ZeropointHolographicVision, ZeropointGoateInsurance,
},


[header: Goate Electric
description: Digital Balances & Universal Swap] {
once clicked take them to a page with the balances of all their assets, and the universal swap where they can choose what asset to swap and what asset to receive it in  and confirm with the pin code or 2fa & the Goate Staking button , lending button, and borrow button at the top of this page; 
assets:
1. $USD,
2. $ZPE,
3. $ZPW,
4. $ZPP
5. $ZHV
6. $ZGI,
7. $SDM,
8. $XLM,
9. $AQUA
10. $yXLM,
11. $yBTC,
12. $yUSD,
13. $EUR,
14. $CHK,
15. $JPY,
16. $VND,
17. $BTC,
18. $BTC (lightning-network),
19. $Pi,
20. $CRO,
21. $UNI,
22. $BNB,
23. $PiB (PiBase / PiBridge)
24. $GOATE
25. $GySt
26. $VVS
25. Stocks {}
and etc assets within instilled interoperability and USDMediator reach an view with apis from dexes, forex assets, stocks, bonds, etfs, and etc.
and add the Goate Staking button to the top of the page
it includes InstilledInteroperability & USDMediator},

[
header: 2 Earn 
description: Engage Without Capital ]{
          once clicked then go to the earn page with the start validation portal button { handles AML/KYC and insuranceClaims} surrounded by a temple palace and adWatch ads playing on the left and right on small screens. Have the Networks and referral links along with a 1. Watch Ad button, 2. a gold click me button
in the bottom left add a " Place an Ad" and add and have add the desrciption with an uploaded video or file and then a button that says "pay $5 a month" and confirm it; once they pay then add it to the lineup of ads to be watched, 
And on the other side o the bottom right a "Get Viewers" button; where people can fill out 1) their name, 2. Their Channel Name or what they are known by, 4. The link to the video that they want people to watch, 5. And how many views they want help with and at the bottom ( they have to pay $10 for every view they want )
},

[
header: Gerastyx'
description: Digital Arcade]{
once they click then they get to the digital arcade page, with more modals to:
1. GerastyxOpol,
2. Spades,
3. HomeTeamBets,
4. PityPat,
5. ScratchOffNFTs,
6. War, 

[
header: Transfer
description: Transfer digital assets & digital utilities with your friends
instilledInteroperability and USDMediator:
when they transfer their assets to someone else then that person receives it 
]

And under the transaction button; the transaction button should be the only button by itself and it should be rectangle and reach both ends of the page; but under the transfer button should be the Transaction History: and it should get posted for everything and is color-coded.



1. index.html -

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goate Electric</title>
    <link rel="stylesheet" href="index.css"> <!-- Updated to match provided filename -->
    <link href="https://fonts.googleapis.com/css2?family=Avenir-Roman&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="banner">
            <div class="logo"><img src="GoateElectricLogo.jpg" alt="Goate Electric Logo"></div>
            <div class="title"><h1>Goate Electric</h1></div>
            <div class="user-section" id="user-section">
                <button id="signup-login">Signup/Login</button>
                <span id="user-email" style="display: none;"></span>
                <button id="logout" style="display: none;">Logout</button>
            </div>
        </div>
        <nav class="navigation" id="navigation" style="display: none;">
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <ul class="nav-menu">
                <li><a href="#home" class="nav-link">Home</a></li>
                <li><a href="#portfolio" class="nav-link">Portfolio</a></li>
                <li><a href="#zeropoint" class="nav-link">Zeropoint</a></li>
                <li><a href="#zeropointwifi" class="nav-link">ZeropointWifi</a></li>
                <li><a href="#zeropointphoneservice" class="nav-link">ZeropointPhoneService</a></li>
                <li><a href="#digital-stocks" class="nav-link">ZeropointDigitalStocks</a></li>
                <li><a href="#swap" class="nav-link">Swap</a></li>
                <li><a href="#goate-staking" class="nav-link">Goate Staking</a></li>
                <li><a href="#hometeambets" class="nav-link">HomeTeamBets</a></li>
                <li><a href="#scratch-off" class="nav-link">Scratch Off NFT</a></li>
                <li><a href="#gerastyxopol" class="nav-link">GerastyxOpol</a></li>
                <li><a href="#earn" class="nav-link">Earn</a></li>
                <li><a href="#manage-devices" class="nav-link">Manage Devices</a></li>
                <li><a href="#settings" class="nav-link">Settings</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section id="home" class="page active">
            <div id="not-logged-in">
                <h2>WELCOME TO GOATE ELECTRIC</h2>
                <p>Access digital utilities that make everyday life easier.</p>
            </div>
            <div id="logged-in" style="display: none;">
                <div class="balances-container">
                    <div class="balance usd-balance"><h3>USD Balance</h3><p id="usd-balance">0</p></div>
                    <div class="balance zpe-balance"><h3>Zeropoint Balance</h3><p id="zeropoint-balance">0</p></div>
                    <div class="balance zpw-balance"><h3>ZeropointWifi Balance</h3><p id="zeropointwifi-balance">0</p></div>
                    <div class="balance zpp-balance"><h3>ZeropointPhone Balance</h3><p id="zeropointphone-balance">0</p></div>
                    <div class="balance gyst-balance"><h3>GreyStax Balance</h3><p id="gyst-balance">0</p></div>
                    <div class="balance goate-balance"><h3>Goate Token Balance</h3><p id="goate-balance">0</p></div> <!-- Added -->
                </div>
                <div class="payment-container">
                    <select id="payment-asset" class="payment-dropdown">
                        <option value="USDC">USDC</option>
                        <option value="ZPE">$ZPE</option>
                        <option value="ZPW">$ZPW</option>
                        <option value="ZPP">$ZPP</option>
                        <option value="GySt">$GySt</option>
                        <option value="XLM">$XLM</option>
                        <option value="GOATE">$GOATE</option> <!-- Added -->
                    </select>
                    <input type="number" id="payment-amount" class="payment-input" placeholder="0.00">
                </div>
                <div class="button-section">
                    <button id="consume-zpe">Consume $ZPE</button>
                    <button id="consume-zpw">Consume $ZPW</button>
                    <button id="subscribe-zpp">Consume $ZPP</button>
                    <button id="airdrop-goate">Airdrop $GOATE</button> <!-- Added -->
                </div>
            </div>
        </section>
        <section id="zeropoint" class="page hidden"><h2>Zeropoint</h2><p>Wireless charging utility, pegged to $0.10.</p></section>
        <section id="zeropointwifi" class="page hidden"><h2>ZeropointWifi</h2><p>Unlimited WiFi, pegged to $5.</p></section>
        <section id="zeropointphoneservice" class="page hidden"><h2>ZeropointPhoneService</h2><p>Phone service utility, pegged to $10.</p></section>
        <section id="earn" class="page hidden">
            <h2>Earn</h2>
            <p>Earn USDC by watching ads.</p>
            <div class="earn-container">
                <button id="watch-google-ad">Watch Google Ad</button>
                <button id="watch-pi-ad">Watch Pi Ad</button>
                <button id="watch-youtube-ad">Watch YouTube Ad</button>
            </div>
            <div id="ad-transaction-history">
                <h3>Transaction History</h3>
                <ul id="history-list"></ul>
            </div>
        </section>
        <section id="swap" class="page hidden">
            <h2>Swap Assets</h2>
            <div id="swap-container">
                <select id="from-asset"></select>
                <input type="number" id="swap-amount" placeholder="Amount">
                <select id="to-asset"></select>
                <select id="to-chain"></select>
                <button id="swap-button">Swap</button>
            </div>
        </section>
        <section id="portfolio" class="page hidden"><h2>Portfolio</h2><ul id="portfolio-list"></ul></section>
        <section id="settings" class="page hidden">
            <h2>Settings</h2>
            <div class="settings-container">
                <div class="bank-actions">
                    <button id="bank-to-goate">Bank to Goate Electric (Deposit)</button>
                    <button id="goate-to-bank">Goate Electric to Bank (Withdraw)</button>
                </div>
                <div class="settings-modal">
                    <h3>Connect Bank</h3>
                    <button id="connect-plaid">Connect with Plaid</button>
                </div>
            </div>
        </section>
        <section id="manage-devices" class="page hidden">
            <h2>Manage Devices</h2>
            <div id="devices-container"></div>
            <input id="device-id" placeholder="Device ID" />
            <button id="add-device">Add Device</button>
            <button id="use-modal">Use Modal</button>
        </section>
        <section id="hometeambets" class="page hidden">
            <h2>HomeTeamBets</h2>
            <p>Bet on your favorite sports games!</p>
            <input type="text" id="sports-search" placeholder="Search Sports Data (e.g., ESPN)..."> <!-- Added -->
            <div id="sports-data-result"></div> <!-- Added -->
            <div id="games-list"></div>
            <div id="bet-transaction-history">
                <h3>Transaction History</h3>
                <ul id="bet-history-list"></ul>
            </div>
        </section>
        <section id="scratch-off" class="page hidden">
            <h2>Scratch Off NFT</h2>
            <div id="scratch-off-container">
                <iframe id="scratch-off-iframe" src="unreal://scratchoffnft" width="100%" height="100%"></iframe>
            </div>
        </section>
        <section id="gerastyxopol" class="page hidden">
            <h2>GerastyxOpol</h2>
            <p>Play a blockchain-based Monopoly game!</p>
            <div id="game-modes">
                <button id="free-play">Free Play</button>
                <button id="reasonable">Reasonable</button>
                <button id="gambling">Gambling</button>
                <button id="rich">Rich</button>
            </div>
            <div id="game-container"></div>
        </section>
        <section id="digital-stocks" class="page hidden">
            <h2>Digital Stocks</h2>
            <input type="text" id="stock-search" placeholder="Search Stocks...">
            <div id="stock-list"></div>
        </section>
        <section id="goate-staking" class="page hidden">
            <h2>Goate Staking</h2>
            <div id="staking-container"></div>
        </section>
    </main>

    <div id="confirmation-modal" class="modal disney-modal" style="display: none;">
        <div class="modal-content disney-modal-content">
            <h3>Confirm Transaction</h3>
            <p id="modal-message"></p>
            <div class="modal-buttons">
                <button id="modal-yes" class="disney-button">Yes</button>
                <button id="modal-no" class="disney-button">No</button>
            </div>
            <div id="pin-section" style="display: none;">
                <input type="password" id="pin-input" maxlength="4" placeholder="Enter PIN">
                <button id="pin-submit" class="disney-button">Submit</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://unpkg.com/stellar-sdk@10.0.1/dist/stellar-sdk.js"></script>
    <script src="https://cdn.plaid.com/link/v2/stable/link-initialize.js"></script>
    <script src="usd-mediator.js"></script>
    <script src="index.js"></script>
</body>
</html>



2. index.css -

html { scroll-behavior: smooth; }
* { box-sizing: border-box; }
body { 
    font-family: 'Avenir-Roman', sans-serif; 
    background: #000000; 
    color: #FFD700; 
    margin: 0; 
    padding: 0; 
}

header { background: #000000; padding: 20px; text-align: center; }
.banner { display: flex; justify-content: space-between; align-items: center; padding: 0 20px; }
.logo img { width: 200px; height: auto; }
.title h1 { margin: 0; font-size: 24px; color: #FFD700; }
.user-section button { 
    padding: 8px 16px; 
    background: #FFD700; 
    color: #000000; 
    border: none; 
    border-radius: 20px; 
    cursor: pointer; 
    font-family: 'Avenir-Roman', sans-serif; 
}
.user-section button:hover { background: #E6C200; }

nav { background: #000000; padding: 0 20px; height: 60px; display: flex; align-items: center; position: relative; }
.hamburger { display: none; flex-direction: column; cursor: pointer; padding: 10px; }
.hamburger span { width: 25px; height: 3px; background: #FFD700; margin: 2px 0; transition: 0.3s; }
.nav-menu { list-style: none; padding: 0; margin: 0; display: flex; }
.nav-menu li { margin: 0 15px; }
.nav-menu a { 
    color: #FFD700; 
    text-decoration: none; 
    padding: 10px 20px; 
    display: block; 
    font-family: 'Avenir-Roman', sans-serif; 
    border-radius: 20px; 
}
.nav-menu a:hover { background: #1a1a1a; }

@media (max-width: 768px) {
    .hamburger { display: flex; }
    .nav-menu { 
        display: none; 
        flex-direction: column; 
        width: 100%; 
        position: absolute; 
        top: 60px; 
        left: 0; 
        background: #000000; 
        border-top: 1px solid #FFD700; 
    }
    .nav-menu.active { display: flex; }
    .nav-menu li { margin: 10px 0; text-align: center; }
}

.page { display: none; padding: 20px; color: #FFD700; }
.page.active { display: block; }

.balances-container { position: relative; width: 300px; height: 300px; margin: 20px auto; }
.usd-balance { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
.zpe-balance { position: absolute; top: 0; left: 50%; transform: translateX(-50%); text-align: center; }
.zpw-balance { position: absolute; bottom: 0; left: 25%; transform: translateX(-50%); text-align: center; }
.zpp-balance { position: absolute; bottom: 0; right: 25%; transform: translateX(50%); text-align: center; }
.gyst-balance { position: absolute; top: 25%; right: 0; transform: translateX(-50%); text-align: center; }

.payment-container { margin: 20px auto; text-align: center; }
.payment-dropdown { 
    padding: 10px; 
    background: #1a1a1a; 
    color: #FFD700; 
    border: 1px solid #FFD700; 
    border-radius: 8px; 
    font-size: 16px; 
    width: 200px; 
    cursor: pointer; 
    font-family: 'Avenir-Roman', sans-serif; 
}
.payment-input { 
    padding: 10px; 
    width: 200px; 
    background: #1a1a1a; 
    color: #FFD700; 
    border: none; 
    border-radius: 8px; 
    font-size: 24px; 
    text-align: center; 
    box-shadow: 0 2px 5px rgba(255, 215, 0, 0.2); 
    transition: all 0.3s ease; 
    font-family: 'Avenir-Roman', sans-serif; 
}
.payment-input:focus { 
    outline: none; 
    box-shadow: 0 4px 10px rgba(255, 215, 0, 0.4); 
}

.button-section { display: flex; justify-content: center; gap: 10px; margin: 20px 0; }
button { 
    padding: 10px 20px; 
    background: #FFD700; 
    color: #000000; 
    border: none; 
    border-radius: 20px; 
    cursor: pointer; 
    font-family: 'Avenir-Roman', sans-serif; 
}
button:hover { background: #E6C200; }

.disney-modal { 
    background: rgba(0, 0, 0, 0.9); 
    border-radius: 15px; 
    backdrop-filter: blur(5px); 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    display: flex; 
    justify-content: center; 
    align-items: center; 
}
.disney-modal-content { 
    background: #1a1a1a; 
    padding: 30px; 
    border-radius: 15px; 
    color: #FFD700; 
    font-family: 'Avenir-Roman', sans-serif; 
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); 
    width: 400px; 
}
.modal-buttons { display: flex; justify-content: space-between; margin-top: 20px; }
.disney-button { 
    background: #FFD700; 
    color: #000000; 
    border: none; 
    padding: 10px 20px; 
    border-radius: 20px; 
    cursor: pointer; 
    font-family: 'Avenir-Roman', sans-serif; 
    transition: transform 0.2s; 
}
.disney-button:hover { 
    background: #E6C200; 
    transform: scale(1.05); 
}
#pin-input { 
    background: #1a1a1a; 
    color: #FFD700; 
    border: 1px solid #FFD700; 
    border-radius: 10px; 
    padding: 8px; 
    font-family: 'Avenir-Roman', sans-serif; 
}

#stock-search { 
    width: 100%; 
    padding: 10px; 
    margin: 20px 0; 
    background: #1a1a1a; 
    color: #FFD700; 
    border: 1px solid #FFD700; 
    border-radius: 10px; 
    font-family: 'Avenir-Roman', sans-serif; 
}
#stock-list { display: flex; flex-wrap: wrap; gap: 20px; }
.stock-card { 
    background: #1a1a1a; 
    padding: 15px; 
    border-radius: 10px; 
    width: 200px; 
    text-align: center; 
    border: 1px solid #FFD700; 
}
#staking-container, #game-container, #scratch-off-container, #games-list { 
    width: 100%; 
    height: 600px; 
    border: 1px solid #FFD700; 
    border-radius: 10px; 
}
#game-modes { display: flex; justify-content: center; gap: 15px; margin: 20px 0; }



3. index.js -

// Web3 provider and signer setup
const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();

// Contract instances (placeholders for addresses and ABIs to be filled in)
const zpeContract = new ethers.Contract("0xYourZPEAddress", zpeABI, signer);
const zpwContract = new ethers.Contract("0xYourZPWAddress", zpwABI, signer);
const zppContract = new ethers.Contract("0xYourZPPAddress", zppABI, signer);
const deviceContract = new ethers.Contract("0xYourDeviceConnectAddress", deviceABI, signer);
const usdcContract = new ethers.Contract("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", usdcABI, signer);
const adWatchContract = new ethers.Contract("0xYourAdWatchAddress", adWatchABI, signer);
const homeTeamBetsContract = new ethers.Contract("0xYourHomeTeamBetsAddress", homeTeamBetsABI, signer);
const gerastyxOpolContract = new ethers.Contract("0xYourGerastyxOpolAddress", gerastyxOpolABI, signer);
const greyStaxContract = new ethers.Contract("0xYourGreyStaxAddress", greyStaxABI, signer);
const digitalStockNFTContract = new ethers.Contract("0xYourDigitalStockNFTAddress", digitalStockNFTABI, signer);
const stakingContract = new ethers.Contract("0xYourGoateStakingAddress", goateStakingABI, signer);
const lendingContract = new ethers.Contract("0xYourLendingAddress", lendingABI, signer);
const interoperabilityContract = new ethers.Contract("0xYourInteroperabilityAddress", interoperabilityABI, signer);
const scratchOffContract = new ethers.Contract("0xYourScratchOffNFTAddress", scratchOffABI, signer);
const goateTokenContract = new ethers.Contract("0xYourGoateTokenAddress", goateABI, signer); // New
const usdMediatorContract = new ethers.Contract("0xYourUSDMediatorAddress", usdMediatorABI, signer); // New
const mediator = new USDMediator(); // Assuming USDMediator is a JS class from usd-mediator.js

// State variables
let currentUser, isLoggedIn = false;
const db = { users: {}, devices: {}};

// Plaid integration
const plaidHandler = Plaid.create({
    token: "YOUR_PLAID_PUBLIC_TOKEN",
    onSuccess: async (publicToken) => {
        const response = await fetch('/plaid/exchange_public_token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ public_token: publicToken })
        });
        const { access_token } = await response.json();
        const creditResponse = await fetch('/plaid/credit_report', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ access_token })
        });
        const creditData = await creditResponse.json();
        console.log("Credit Score:", creditData.credit_score);
    },
    onExit: (err) => console.error(err)
});

// Update user balances including Goate Token
async function updateBalances() {
    const userAddress = await signer.getAddress();
    document.getElementById('usd-balance').textContent = ethers.utils.formatUnits(await usdcContract.balanceOf(userAddress), 6);
    document.getElementById('zeropoint-balance').textContent = ethers.utils.formatUnits(await zpeContract.balanceOf(userAddress), 3);
    document.getElementById('zeropointwifi-balance').textContent = ethers.utils.formatUnits(await zpwContract.balanceOf(userAddress), 2);
    document.getElementById('zeropointphone-balance').textContent = ethers.utils.formatUnits(await zppContract.balanceOf(userAddress), 2);
    document.getElementById('gyst-balance').textContent = ethers.utils.formatUnits(await greyStaxContract.balanceOf(userAddress), 18);
    document.getElementById('goate-balance').textContent = ethers.utils.formatUnits(await goateTokenContract.balanceOf(userAddress), 18);
}

// Initialize digital stocks
async function initializeStocks() {
    const response = await fetch('https://api.alpaca.markets/v2/assets', {
        headers: { 
            'APCA-API-KEY-ID': 'YOUR_ALPACA_KEY', 
            'APCA-API-SECRET-KEY': 'YOUR_ALPACA_SECRET' 
        }
    });
    const stocks = await response.json();
    for (const stock of stocks) {
        await digitalStockNFTContract.mintStock("0xYourOwnerAddress", stock.symbol);
    }
}

// Load stock list
async function loadStocks() {
    const stockList = document.getElementById('stock-list');
    stockList.innerHTML = '';
    const tokenCount = await digitalStockNFTContract.tokenCounter();
    for (let i = 0; i < tokenCount; i++) {
        const symbol = await digitalStockNFTContract.stockSymbols(i);
        stockList.innerHTML += `
            <div class="stock-card">
                <h3>${symbol}</h3>
                <input type="number" id="amount-${i}" placeholder="Amount (USDC)">
                <select id="chain-${i}">
                    <option value="1">Ethereum</option>
                    <option value="512">Stellar</option>
                </select>
                <button onclick="buyStock(${i})">Buy</button>
                <button onclick="sellStock(${i})">Sell</button>
            </div>
        `;
    }
}

// Buy stock
async function buyStock(tokenId) {
    const amount = ethers.utils.parseUnits(document.getElementById(`amount-${tokenId}`).value, 6);
    const chainId = document.getElementById(`chain-${tokenId}`).value;
    await confirmTransaction(`Buy ${await digitalStockNFTContract.stockSymbols(tokenId)} for ${ethers.utils.formatUnits(amount, 6)} USDC?`, async () => {
        await usdcContract.approve(digitalStockNFTContract.address, amount);
        await digitalStockNFTContract.buyStock(tokenId, amount, chainId);
        updateBalances();
        loadStocks();
    });
}

// Sell stock
async function sellStock(tokenId) {
    const amount = ethers.utils.parseUnits(document.getElementById(`amount-${tokenId}`).value, 6);
    await confirmTransaction(`Sell ${await digitalStockNFTContract.stockSymbols(tokenId)} for ${ethers.utils.formatUnits(amount, 6)} USDC?`, async () => {
        await digitalStockNFTContract.sellStock(tokenId, amount, "USDC", 1);
        updateBalances();
        loadStocks();
    });
}

// Load HomeTeamBets games
async function loadGames() {
    const gamesList = document.getElementById('games-list');
    gamesList.innerHTML = '';
    const gameCount = await homeTeamBetsContract.gameCount();
    for (let i = 0; i < gameCount; i++) {
        const game = await homeTeamBetsContract.games(i);
        gamesList.innerHTML += `
            <div class="game-card">
                <h3>${game.homeTeam} vs ${game.awayTeam}</h3>
                <p>Start: ${new Date(game.startTime * 1000).toLocaleString()}</p>
                <p>Pool: ${ethers.utils.formatUnits(game.totalPool, 6)} USDC</p>
                <select id="bet-type-${i}">
                    <option value="0">Win</option>
                    <option value="1">Lose</option>
                    <option value="2">Tie</option>
                </select>
                <input type="checkbox" id="overtime-${i}"> Overtime?
                <input type="number" id="bet-amount-${i}" placeholder="Bet Amount (USDC)">
                <button onclick="placeBet(${i})">Place Bet</button>
            </div>
        `;
    }
}

// Place a bet
async function placeBet(gameId) {
    const amount = ethers.utils.parseUnits(document.getElementById(`bet-amount-${gameId}`).value, 6);
    const betType = document.getElementById(`bet-type-${gameId}`).value;
    const overtime = document.getElementById(`overtime-${gameId}`).checked;
    await confirmTransaction(`Place ${ethers.utils.formatUnits(amount, 6)} USDC bet on Game ${gameId}?`, async () => {
        await usdcContract.approve(homeTeamBetsContract.address, amount);
        await homeTeamBetsContract.placeBet(gameId, amount, betType, overtime);
        updateBalances();
        loadGames();
    });
}

// Load staking iframe
async function loadStaking() {
    const stakingContainer = document.getElementById('staking-container');
    stakingContainer.innerHTML = `<iframe src="unreal://goatestaking" width="100%" height="100%"></iframe>`;
}

// Load scratch-off iframe
async function loadScratchOff() {
    const scratchOffContainer = document.getElementById('scratch-off-container');
    scratchOffContainer.innerHTML = `<iframe src="unreal://scratchoffnft" width="100%" height="100%"></iframe>`;
}

// Scratch an NFT
async function scratchNFT(mode, asset, chainId) {
    const amounts = { "Pennies": "1", "Nickels": "5", "Dimes": "10", "Quarters": "25", "Dollars": "100" };
    const amount = ethers.utils.parseUnits(amounts[mode], 6);
    await confirmTransaction(`Scratch ${mode} NFT for ${amounts[mode]} ${asset} on Chain ${chainId}?`, async () => {
        const token = new ethers.Contract(interoperabilityContract.tokenMap(chainId, asset), erc20ABI, signer);
        await token.approve(scratchOffContract.address, amount);
        await scratchOffContract.scratch(asset, mode === "Pennies" ? 0 : mode === "Nickels" ? 1 : mode === "Dimes" ? 2 : mode === "Quarters" ? 3 : 4, chainId);
        updateBalances();
    });
}

// Stake assets
async function stake(asset, amount, duration) {
    await confirmTransaction(`Stake ${amount} ${asset} for ${duration} seconds?`, async () => {
        const token = new ethers.Contract(interoperabilityContract.tokenMap(1, asset), erc20ABI, signer);
        await token.approve(stakingContract.address, amount);
        await stakingContract.stake(asset, amount, duration);
        updateBalances();
    });
}

// Lending functions
async function lend(amount) {
    await confirmTransaction(`Lend ${amount} USDC?`, async () => {
        await usdcContract.approve(lendingContract.address, amount);
        await lendingContract.lend(amount);
        updateBalances();
    });
}

async function borrow(amount) {
    await confirmTransaction(`Borrow ${amount} USDC?`, async () => {
        await lendingContract.borrow(amount);
        updateBalances();
    });
}

async function repay(amount) {
    await confirmTransaction(`Repay ${amount} USDC?`, async () => {
        await usdcContract.approve(lendingContract.address, amount);
        await lendingContract.repay(amount);
        updateBalances();
    });
}

// Start GerastyxOpol game
async function startGame(mode) {
    const sessionId = await gerastyxOpolContract.sessionCount();
    if (mode === "FreePlay") {
        await confirmTransaction("Start Free Play session?", async () => {
            await gerastyxOpolContract.startSession(0, 0);
            loadGame(sessionId);
        });
    } else {
        const fee = mode === "Reasonable" ? "1" : mode === "Gambling" ? "5" : "20";
        await confirmTransaction(`Start ${mode} session for ${fee} USDC?`, async () => {
            await usdcContract.approve(gerastyxOpolContract.address, ethers.utils.parseUnits(fee, 6));
            await gerastyxOpolContract.startSession(mode === "Reasonable" ? 1 : mode === "Gambling" ? 2 : 3, ethers.utils.parseUnits(fee, 6));
            loadGame(sessionId);
        });
    }
}

// Load GerastyxOpol game iframe
function loadGame(sessionId) {
    const gameContainer = document.getElementById('game-container');
    gameContainer.innerHTML = `<iframe src="unreal://gerastyxopol?session=${sessionId}" width="100%" height="100%"></iframe>`;
}

// Confirmation modal logic
async function confirmTransaction(message, callback) {
    const modal = document.getElementById('confirmation-modal');
    const messageEl = document.getElementById('modal-message');
    const yesBtn = document.getElementById('modal-yes');
    const noBtn = document.getElementById('modal-no');
    const pinSection = document.getElementById('pin-section');
    const pinInput = document.getElementById('pin-input');
    const pinSubmit = document.getElementById('pin-submit');

    messageEl.textContent = message;
    modal.style.display = 'flex';
    pinSection.style.display = 'none';

    return new Promise((resolve) => {
        yesBtn.onclick = () => {
            pinSection.style.display = 'block';
            yesBtn.style.display = 'none';
            noBtn.style.display = 'none';
        };
        noBtn.onclick = () => {
            modal.style.display = 'none';
            resolve(false);
        };
        pinSubmit.onclick = () => {
            if (pinInput.value.length === 4) {
                modal.style.display = 'none';
                callback();
                resolve(true);
            }
        };
    });
}

// Load user devices
async function loadDevices() {
    const userAddress = await signer.getAddress();
    const devices = await deviceContract.getUserDevices(userAddress);
    const container = document.getElementById('devices-container');
    container.innerHTML = devices.map(device => `
        <div class="device-card">
            <span>${device.deviceId} (Modals: ${device.modalCount})</span>
            <div class="slider-group">
                <button class="slider-btn on ${device.isActive ? 'active' : ''}" data-device="${device.deviceId}">On</button>
                <button class="slider-btn off ${!device.isActive ? 'active' : ''}" data-device="${device.deviceId}">Off</button>
            </div>
        </div>
    `).join('');
}

// Watch ads
async function watchAd(adType) {
    await confirmTransaction(`Watch ${adType} Ad?`, async () => {
        const adContainer = document.createElement("div");
        adContainer.style.position = "fixed";
        adContainer.style.top = "0";
        adContainer.style.left = "0";
        adContainer.style.width = "100vw";
        adContainer.style.height = "100vh";
        adContainer.style.background = "black";
        adContainer.style.color = "#FFD700";
        adContainer.style.display = "flex";
        adContainer.style.justifyContent = "center";
        adContainer.style.alignItems = "center";
        adContainer.innerHTML = `<p>Watching ${adType} Ad... (30s)</p>`;
        document.body.appendChild(adContainer);

        await new Promise(resolve => setTimeout(resolve, 30000));
        document.body.removeChild(adContainer);

        await mediator.handleAdWatch(adType, await signer.getAddress());
        updateBalances();
    });
}

// Airdrop Goate Tokens
async function airdropGoate() {
    const achievementPoints = 1; // Example value, could be dynamic
    await confirmTransaction(`Airdrop ${achievementPoints * 10} $GOATE for ${achievementPoints} achievement points?`, async () => {
        await goateTokenContract.recordAchievement(await signer.getAddress(), achievementPoints);
        updateBalances();
    });
}

// Search sports data
async function searchSportsData(query) {
    const resultDiv = document.getElementById('sports-data-result');
    try {
        const data = await usdMediatorContract.readSportsData(query);
        resultDiv.innerHTML = `<p>Sports Data API: ${data}</p>`;
    } catch (error) {
        resultDiv.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}

// Update UI based on login state
function updateUI() {
    document.getElementById('logged-in').style.display = isLoggedIn ? 'block' : 'none';
    document.getElementById('not-logged-in').style.display = isLoggedIn ? 'none' : 'block';
    document.getElementById('navigation').style.display = isLoggedIn ? 'flex' : 'none';
    document.getElementById('signup-login').style.display = isLoggedIn ? 'none' : 'inline';
    document.getElementById('user-email').style.display = isLoggedIn ? 'inline' : 'none';
    document.getElementById('logout').style.display = isLoggedIn ? 'inline' : 'none';
    if (isLoggedIn) {
        document.getElementById('user-email').textContent = currentUser;
        updateBalances();
        loadDevices();
    }
}

// DOM content loaded event listener
document.addEventListener('DOMContentLoaded', async () => {
    await provider.send("eth_requestAccounts", []);
    await initializeStocks();

    const hamburger = document.querySelector('.hamburger');
    const navMenu = document.querySelector('.nav-menu');
    hamburger.addEventListener('click', () => {
        navMenu.classList.toggle('active');
        hamburger.classList.toggle('open');
        if (hamburger.classList.contains('open')) {
            hamburger.children[0].style.transform = 'rotate(45deg) translate(5px, 5px)';
            hamburger.children[1].style.opacity = '0';
            hamburger.children[2].style.transform = 'rotate(-45deg) translate(5px, -5px)';
        } else {
            hamburger.children[0].style.transform = 'none';
            hamburger.children[1].style.opacity = '1';
            hamburger.children[2].style.transform = 'none';
        }
    });

    document.getElementById('signup-login').addEventListener('click', () => {
        currentUser = "user@example.com";
        isLoggedIn = true;
        updateUI();
    });

    document.getElementById('logout').addEventListener('click', () => {
        isLoggedIn = false;
        currentUser = null;
        updateUI();
    });

    document.getElementById('consume-zpe').addEventListener('click', async () => {
        const amount = document.getElementById('payment-amount').value;
        await confirmTransaction(`Consume ${amount || 1} $ZPE?`, async () => {
            await zpeContract.consumeForService(ethers.utils.parseUnits(amount || "1", 3));
            updateBalances();
        });
    });

    document.getElementById('consume-zpw').addEventListener('click', async () => {
        const amount = document.getElementById('payment-amount').value;
        await confirmTransaction(`Consume ${amount || 1} $ZPW?`, async () => {
            await zpwContract.burn(ethers.utils.parseUnits(amount || "1", 2));
            updateBalances();
        });
    });

    document.getElementById('subscribe-zpp').addEventListener('click', async () => {
        await confirmTransaction(`Subscribe with $ZPP?`, async () => {
            await zppContract.subscribe();
            updateBalances();
        });
    });

    document.getElementById('add-device').addEventListener('click', async () => {
        const deviceId = document.getElementById('device-id').value;
        await confirmTransaction(`Add Device ${deviceId}?`, async () => {
            await deviceContract.addDevice(deviceId);
            loadDevices();
        });
    });

    document.getElementById('watch-google-ad').addEventListener('click', () => watchAd("Google"));
    document.getElementById('watch-pi-ad').addEventListener('click', () => watchAd("Pi"));
    document.getElementById('watch-youtube-ad').addEventListener('click', () => watchAd("YouTube"));

    document.getElementById('free-play').addEventListener('click', () => startGame("FreePlay"));
    document.getElementById('reasonable').addEventListener('click', () => startGame("Reasonable"));
    document.getElementById('gambling').addEventListener('click', () => startGame("Gambling"));
    document.getElementById('rich').addEventListener('click', () => startGame("Rich"));

    document.getElementById('connect-plaid').addEventListener('click', () => plaidHandler.open());

    // New event listeners
    document.getElementById('airdrop-goate').addEventListener('click', airdropGoate);
    document.getElementById('sports-search').addEventListener('input', (e) => searchSportsData(e.target.value));

    document.querySelectorAll('.nav-link').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            const section = document.querySelector(link.getAttribute('href'));
            section.classList.add('active');
            navMenu.classList.remove('active');
            hamburger.classList.remove('open');
            hamburger.children[0].style.transform = 'none';
            hamburger.children[1].style.opacity = '1';
            hamburger.children[2].style.transform = 'none';

            // Load section-specific content
            if (link.getAttribute('href') === '#digital-stocks') loadStocks();
            if (link.getAttribute('href') === '#hometeambets') loadGames();
            if (link.getAttribute('href') === '#goate-staking') loadStaking();
            if (link.getAttribute('href') === '#scratch-off') loadScratchOff();
        });
    });
});


4. usd-mediator.js -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./InstilledInteroperability.sol";
import "./TheGoateToken.sol";

contract USDMediator {
    InstilledInteroperability public interoperability;
    IERC20 public usdcToken = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    TheGoateToken public goateToken;
    address public owner;
    address public piAddress = 0x1234567890abcdef1234567890abcdef12345678; // Placeholder for $PI

    mapping(string => string) public tradingAPIs;
    mapping(string => string) public sportsDataAPIs;
    mapping(address => bool) public allowedViewers; // Viewer access control
    string[] public reserveAssets = [
        "WMT", "KMB", "MO", "WPC", "CSCO", "T", "BX", "AAPL", "CAT", "SPG",
        "LMT", "AVY", "MCD", "TGT", "TTWO", "DIS", "BAC", "BBY", "MGY", "NKE",
        "USD", "ZPE", "ZPW", "ZPP", "GySt", "XLM", "PI", "GerastyxOpolBank"
    ];

    event RevenueDistributed(uint256 amount, address cj03nes, address reserves, address mediator, address piAddress);
    event DataRead(address indexed reader, string dataType, string data);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier onlyAllowedViewer() {
        require(allowedViewers[msg.sender] || msg.sender == owner, "Not allowed to view");
        _;
    }

    constructor(address _interoperability, address _goateToken) {
        owner = msg.sender;
        interoperability = InstilledInteroperability(_interoperability);
        goateToken = TheGoateToken(_goateToken);
        allowedViewers[owner] = true;
        // Trading APIs from provided version
        tradingAPIs["Alpaca"] = "https://api.alpaca.markets";
        tradingAPIs["Tradier"] = "https://api.tradier.com";
        tradingAPIs["SnapTrade"] = "https://api.snaptrade.com";
        tradingAPIs["ETrade"] = "https://api.etrade.com";
        tradingAPIs["TradeStation"] = "https://api.tradestation.com";
        tradingAPIs["Questrade"] = "https://api.questrade.com";
        tradingAPIs["Stellar"] = "https://horizon.stellar.org";
        tradingAPIs["Aquarius"] = "https://api.aquariusdex.com";
        tradingAPIs["MoonPay"] = "https://api.moonpay.com";
        tradingAPIs["1inch"] = "https://api.1inch.exchange/v5.0";
        tradingAPIs["Uniswap"] = "https://api.uniswap.org/v1";
        tradingAPIs["PancakeSwap"] = "https://api.pancakeswap.info/api/v2";
        tradingAPIs["OKX"] = "https://www.okx.com/api/v5";
        tradingAPIs["SushiSwap"] = "https://api.sushiswap.org/v1";
        // Sports Data APIs
        sportsDataAPIs["ESPN"] = "https://api.espn.com";
        sportsDataAPIs["SportsRadar"] = "https://api.sportsradar.com";
    }

    // Updated revenue distribution with $PI allocation
    function distributeRevenue(uint256 amount) internal {
        address cj03nes = 0xYourCj03nesAddress; // Placeholder
        address reserves = 0xYourReservesAddress; // Placeholder
        address mediator = 0xYourMediatorAddress; // Placeholder
        uint256 piShare = amount * 2 / 100; // 2% to $PI
        uint256 remaining = amount - piShare;
        usdcToken.transfer(cj03nes, remaining * 80 / 100);
        usdcToken.transfer(reserves, remaining * 15 / 100);
        usdcToken.transfer(mediator, remaining * 5 / 100);
        usdcToken.transfer(piAddress, piShare);
        emit RevenueDistributed(amount, cj03nes, reserves, mediator, piAddress);
    }

    // Read sports data
    function readSportsData(string memory apiName) external onlyAllowedViewer returns (string memory) {
        string memory data = sportsDataAPIs[apiName];
        emit DataRead(msg.sender, "sports", data);
        return data;
    }

    // Manage allowed viewers
    function setViewer(address viewer, bool allowed) external onlyOwner {
        allowedViewers[viewer] = allowed;
    }

    // Stock trading functions from provided version
    function buyStock(string memory stockSymbol, uint256 amount) external {
        require(amount > 0, "Amount must be greater than 0");
        require(usdcToken.transferFrom(msg.sender, address(this), amount), "Transfer failed");
        uint256 revenue = amount * 5 / 100;
        distributeRevenue(revenue);
    }

    function sellStock(string memory stockSymbol, uint256 amount, string memory toAsset, address recipient) external {
        uint256 usdAmount = amount;
        uint256 revenue = usdAmount * 5 / 100;
        distributeRevenue(revenue);
        uint256 netAmount = usdAmount - revenue;
        interoperability.crossChainTransfer(1, 1, toAsset, netAmount, recipient);
    }

    // Transfer USD (restricted to ScratchOffNFT or owner)
    function transferUSD(address to, uint256 amount) external {
        require(msg.sender == address(0xYourScratchOffNFTAddress) || msg.sender == owner, "Unauthorized"); // Placeholder
        require(usdcToken.transfer(to, amount), "Transfer failed");
    }

    // Swap assets
    function swap(string memory fromAsset, string memory toAsset, uint256 amount, uint256 chainId) external {
        address fromToken = interoperability.tokenMap(chainId, fromAsset);
        address toToken = interoperability.tokenMap(chainId, toAsset);
        require(IERC20(fromToken).transferFrom(msg.sender, address(this), amount), "Transfer failed");
        interoperability.crossChainTransfer(chainId, chainId, toAsset, amount, msg.sender);
    }

    // Stake debt
    function stakeDebt(address user, uint256 amount) external {
        uint256 perAsset = amount / reserveAssets.length;
        for (uint256 i = 0; i < reserveAssets.length; i++) {
            if (keccak256(abi.encodePacked(reserveAssets[i])) == keccak256(abi.encodePacked("USD"))) {
                usdcToken.transfer(address(this), perAsset);
            } else {
                buyStock(reserveAssets[i], perAsset);
            }
        }
    }

    // Distribute staking revenue
    function distributeStakingRevenue(uint256 amount) external {
        uint256 revenue = amount * 10 / 100;
        uint256 reserve = amount * 10 / 100;
        uint256 userShare = amount * 80 / 100;
        distributeRevenue(revenue);
        uint256 perReserve = reserve / reserveAssets.length;
        for (uint256 i = 0; i < reserveAssets.length; i++) {
            buyStock(reserveAssets[i], perReserve);
        }
    }

    // Handle ad watch (placeholder)
    function handleAdWatch(string memory adType, address user) external {
        // Off-chain logic in usd-mediator.js or AdWatch.sol integration
    }

    // Handle GerastyxOpol transaction
    function handleGerastyxOpolTransaction(uint256 sessionId, uint256 amount, string memory type_) external {
        distributeRevenue(amount * 5 / 100);
    }

    // Handle ScratchOff payment
    function handleScratchOffPayment(string memory asset, uint256 amount, uint256 chainId) external {
        address tokenAddress = interoperability.tokenMap(chainId, asset);
        IERC20 token = IERC20(tokenAddress);
        uint256 half = amount / 2;
        require(token.transferFrom(msg.sender, address(this), half), "Mediator transfer failed");
        require(token.transfer(0xYourRevenueAddress, half), "Revenue transfer failed"); // Placeholder
    }
}


5. AdWatch.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./InstilledInteroperability.sol";

contract AdWatch {
    InstilledInteroperability public interoperability;
    IERC20 public usdcToken; // USDC contract
    address public owner;
    uint256 public totalRevenue; // 20% revenue in USDC

    struct AdTransaction {
        address viewer;
        uint256 timestamp;
        uint256 payout; // 80% in USDC
        string adType; // "Google", "Pi", "YouTube"
    }

    mapping(address => AdTransaction[]) public transactionHistory;

    event AdWatched(address indexed viewer, uint256 payout, string adType, uint256 timestamp);
    event RevenueDistributed(address indexed viewer, uint256 viewerShare, uint256 revenueShare);

    constructor(address _interoperability, address _usdcToken) {
        owner = msg.sender;
        interoperability = InstilledInteroperability(_interoperability);
        usdcToken = IERC20(_usdcToken); // USDC address: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48
    }

    function watchAd(string memory adType, uint256 amount) external {
        require(amount > 0, "No payment received for ad view");

        // Transfer USDC from mediator (off-chain revenue source) to this contract
        require(usdcToken.transferFrom(msg.sender, address(this), amount), "USDC transfer failed");

        // Calculate shares: 80% to viewer, 20% to revenue
        uint256 viewerShare = (amount * 80) / 100;
        uint256 revenueShare = amount - viewerShare;

        // Update total revenue
        totalRevenue += revenueShare;

        // Record transaction
        AdTransaction memory newTransaction = AdTransaction({
            viewer: msg.sender,
            timestamp: block.timestamp,
            payout: viewerShare,
            adType: adType
        });
        transactionHistory[msg.sender].push(newTransaction);

        // Send 80% to the viewer via crossChainTransfer
        interoperability.crossChainTransfer(1, 1, "USDC", viewerShare, msg.sender);

        // Emit events
        emit AdWatched(msg.sender, viewerShare, adType, block.timestamp);
        emit RevenueDistributed(msg.sender, viewerShare, revenueShare);
    }

    // Withdraw accumulated revenue (20%) to mediator account
    function withdrawRevenue() external {
        require(msg.sender == owner, "Only owner can withdraw");
        uint256 amount = totalRevenue;
        totalRevenue = 0;
        interoperability.crossChainTransfer(1, 1, "USDC", amount, interoperability.mediatorAccount());
    }

    // Get a user's transaction history
    function getTransactionHistory(address user) external view returns (AdTransaction[] memory) {
        return transactionHistory[user];
    }
}



6. DeviceConnect.sol - 

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./InstilledInteroperability.sol";

contract DeviceConnect is Ownable {
    InstilledInteroperability public interoperability;
    uint256 public constant FREE_MODALS = 5;
    uint256 public constant MODAL_COST = 1 * 10**6; // $1 in USDC (6 decimals)
    address public revenueRecipient;

    struct Device {
        string deviceId;
        bool isActive;
        uint256 modalCount;
    }
    mapping(address => Device[]) public userDevices;
    mapping(string => bool) public deviceExists;

    constructor(address _interoperability, address initialOwner) Ownable(initialOwner) {
        interoperability = InstilledInteroperability(_interoperability);
    }

    function setRevenueRecipient(address recipient) external onlyOwner {
        revenueRecipient = recipient;
    }

    function addDevice(string memory deviceId) external {
        require(!deviceExists[deviceId], "Device already exists");
        userDevices[msg.sender].push(Device(deviceId, true, 0));
        deviceExists[deviceId] = true;
    }

    function disconnectDevice(string memory deviceId) external {
        Device[] storage devices = userDevices[msg.sender];
        for (uint256 i = 0; i < devices.length; i++) {
            if (keccak256(bytes(devices[i].deviceId)) == keccak256(bytes(deviceId)) && devices[i].isActive) {
                devices[i].isActive = false;
                return;
            }
        }
        revert("Device not found or already disconnected");
    }

    function useModal(string memory deviceId) external {
        Device[] storage devices = userDevices[msg.sender];
        for (uint256 i = 0; i < devices.length; i++) {
            if (keccak256(bytes(devices[i].deviceId)) == keccak256(bytes(deviceId)) && devices[i].isActive) {
                if (devices[i].modalCount < FREE_MODALS) {
                    devices[i].modalCount++;
                } else {
                    require(revenueRecipient != address(0), "Revenue recipient not set");
                    interoperability.crossChainTransfer(1, 1, "USDC", MODAL_COST, revenueRecipient);
                    devices[i].modalCount++;
                }
                return;
            }
        }
        revert("Active device not found");
    }

    function getUserDevices(address user) external view returns (Device[] memory) {
        return userDevices[user];
    }

    function isDeviceActive(string memory deviceId) external view returns (bool) {
        Device[] memory devices = userDevices[msg.sender];
        for (uint256 i = 0; i < devices.length; i++) {
            if (keccak256(bytes(devices[i].deviceId)) == keccak256(bytes(deviceId))) {
                return devices[i].isActive;
            }
        }
        return false;
    }
}

7. GerastyxOpol.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./USDMediator.sol";
import "./InstilledInteroperability.sol";

contract Lending {
    USDMediator public usdMediator;
    InstilledInteroperability public interoperability;
    address public owner;
    string public plaidAPI = "https://api.plaid.com";

    uint256 public borrowPool;
    mapping(address => uint256) public loans;
    mapping(address => uint256) public loanDueDates;
    mapping(address => uint256) public creditScores;

    string[] public stockList = [
        "WMT", "KMB", "MO", "WPC", "CSCO", "T", "BX", "AAPL", "CAT", "SPG",
        "LMT", "AVY", "MCD", "TGT", "TTWO", "DIS", "BAC", "BBY", "MGY", "NKE"
    ];

    event Lent(address indexed user, uint256 amount);
    event Borrowed(address indexed user, uint256 amount);
    event Repaid(address indexed user, uint256 amount);

    constructor(address _usdMediator, address _interoperability) {
        owner = msg.sender;
        usdMediator = USDMediator(_usdMediator);
        interoperability = InstilledInteroperability(_interoperability);
    }

    function lend(uint256 amount) external {
        require(amount >= 1e6, "Minimum $1 USD");
        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        require(usdc.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        uint256 perStock = amount / 20;
        for (uint256 i = 0; i < stockList.length; i++) {
            usdMediator.buyStock(stockList[i], perStock);
        }
        borrowPool += amount;
        emit Lent(msg.sender, amount);
    }

    function borrow(uint256 amount) external {
        uint256 creditScore = getCreditScore(msg.sender);
        uint256 ecosystemSize = 1000; // Placeholder
        uint256 maxLoan = (creditScore * borrowPool) / (1000 * ecosystemSize);
        require(amount <= maxLoan, "Exceeds loan limit");
        require(loans[msg.sender] == 0, "Existing loan pending");
        require(borrowPool >= amount, "Insufficient pool");

        borrowPool -= amount;
        loans[msg.sender] = amount;
        loanDueDates[msg.sender] = block.timestamp + 30 days;
        usdMediator.transferUSD(msg.sender, amount);
        emit Borrowed(msg.sender, amount);
    }

    function repay(uint256 amount) external {
        require(loans[msg.sender] >= amount, "Invalid amount");
        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        require(usdc.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        loans[msg.sender] -= amount;
        borrowPool += amount;
        if (loans[msg.sender] == 0) loanDueDates[msg.sender] = 0;
        emit Repaid(msg.sender, amount);
    }

    function handleDefault(address user) external {
        require(loanDueDates[user] != 0 && block.timestamp > loanDueDates[user], "Not defaulted");
        uint256 debt = loans[user];
        usdMediator.stakeDebt(user, debt);
        loans[user] = 0;
        loanDueDates[user] = 0;
    }

    function getCreditScore(address user) internal returns (uint256) {
        if (creditScores[user] == 0) {
            creditScores[user] = 700; // Default, updated off-chain via Plaid
        }
        return creditScores[user];
    }
}

8. GerastyxPropertyNFT.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract GerastyxPropertyNFT is ERC721, Ownable {
    uint256 public constant TOTAL_SUPPLY = 1_000_000_000;
    uint256 public tokenCounter;
    mapping(uint256 => uint256) public propertyValues;

    constructor() ERC721("GerastyxPropertyNFT", "GPNFT") Ownable(msg.sender) {
        initializeProperties();
    }

    function initializeProperties() internal {
        propertyValues[1] = 100e18; // Duck Crossing
        propertyValues[2] = 110e18; // Duck Coast
    }

    function mint(address to, uint256 tokenId) external onlyOwner {
        require(tokenCounter < TOTAL_SUPPLY, "Max supply reached");
        _safeMint(to, tokenId);
        tokenCounter++;
    }
}

9. GoateStaking.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./USDMediator.sol";
import "./InstilledInteroperability.sol";

contract GoateStaking {
    USDMediator public usdMediator;
    InstilledInteroperability public interoperability;
    address public owner;

    struct Stake {
        address user;
        string asset;
        uint256 amount;
        uint256 startTime;
        uint256 duration;
        bool active;
    }

    mapping(address => Stake[]) public stakes;
    mapping(address => uint256) public totalStaked;

    string[] public stockList = [
        "WMT", "KMB", "MO", "WPC", "CSCO", "T", "BX", "AAPL", "CAT", "SPG",
        "LMT", "AVY", "MCD", "TGT", "TTWO", "DIS", "BAC", "BBY", "MGY", "NKE"
    ];

    event Staked(address indexed user, string asset, uint256 amount, uint256 duration);
    event Unstaked(address indexed user, string asset, uint256 amount);

    constructor(address _usdMediator, address _interoperability) {
        owner = msg.sender;
        usdMediator = USDMediator(_usdMediator);
        interoperability = InstilledInteroperability(_interoperability);
    }

    function stake(string memory asset, uint256 amount, uint256 duration) external {
        require(amount >= 1e6, "Minimum $1 USD");
        IERC20 token = IERC20(interoperability.tokenMap(block.chainid, asset));
        require(token.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        uint256 perStock = amount / 20;
        for (uint256 i = 0; i < stockList.length; i++) {
            usdMediator.buyStock(stockList[i], perStock);
        }

        stakes[msg.sender].push(Stake(msg.sender, asset, amount, block.timestamp, duration, true));
        totalStaked[msg.sender] += amount;

        emit Staked(msg.sender, asset, amount, duration);
    }

    function unstake(uint256 stakeId) external {
        Stake storage stake = stakes[msg.sender][stakeId];
        require(stake.active, "Stake not active");
        require(block.timestamp >= stake.startTime + stake.duration, "Stake not matured");

        uint256 perStock = stake.amount / 20;
        for (uint256 i = 0; i < stockList.length; i++) {
            usdMediator.sellStock(stockList[i], perStock, stake.asset, msg.sender);
        }

        stake.active = false;
        totalStaked[msg.sender] -= stake.amount;

        emit Unstaked(msg.sender, stake.asset, stake.amount);
    }
}

10. GreyStax.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract GreyStax is ERC20, Ownable {
    constructor() ERC20("GreyStax", "GySt") Ownable(msg.sender) {}

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external onlyOwner {
        _burn(from, amount);
    }
}

11. HomeTeamBets.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "./InstilledInteroperability.sol";
import "./USDMediator.sol";

contract HomeTeamBets {
    InstilledInteroperability public interoperability;
    USDMediator public usdMediator;
    IERC20 public usdcToken = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    address public owner;
    uint256 public totalRevenue;

    enum BetType { Win, Lose, Tie }

    struct Bet {
        address bettor;
        uint256 amount;
        BetType betType;
        bool overtime;
        uint256 timestamp;
    }

    struct Game {
        string homeTeam;
        string awayTeam;
        uint256 startTime;
        bool isActive;
        uint256 totalPool;
        bool completed;
        BetType result;
        bool hadOvertime;
        mapping(address => Bet) bets;
        address[] bettors;
    }

    mapping(uint256 => Game) public games;
    mapping(address => mapping(uint256 => bool)) public hasBet;
    mapping(address => Bet[]) public transactionHistory;

    AggregatorV3Interface public oracle;
    uint256 public gameCount;

    event BetPlaced(address indexed bettor, uint256 gameId, uint256 amount, BetType betType, bool overtime, uint256 timestamp);
    event GameStarted(uint256 gameId, uint256 startTime);
    event GameCompleted(uint256 gameId, BetType result, bool hadOvertime);
    event WinningsDistributed(address indexed winner, uint256 gameId, uint256 amount);

    constructor(address _interoperability, address _usdMediator, address _oracle) {
        owner = msg.sender;
        interoperability = InstilledInteroperability(_interoperability);
        usdMediator = USDMediator(_usdMediator);
        oracle = AggregatorV3Interface(_oracle);
    }

    function createGame(string memory _homeTeam, string memory _awayTeam, uint256 _startTime) external {
        require(msg.sender == owner, "Only owner can create games");
        require(_startTime > block.timestamp, "Start time must be in the future");

        Game storage game = games[gameCount];
        game.homeTeam = _homeTeam;
        game.awayTeam = _awayTeam;
        game.startTime = _startTime;
        game.isActive = true;
        gameCount++;

        emit GameStarted(gameCount - 1, _startTime);
    }

    function placeBet(uint256 _gameId, uint256 _amount, BetType _betType, bool _overtime) external {
        Game storage game = games[_gameId];
        require(game.isActive, "Betting closed or game not found");
        require(block.timestamp < game.startTime - 5 minutes, "Betting closes 5 mins before start");
        require(!hasBet[msg.sender][_gameId], "One bet per game allowed");
        require(_amount > 0, "Amount must be greater than 0");

        require(usdcToken.transferFrom(msg.sender, address(this), _amount), "USDC transfer failed");

        game.bets[msg.sender] = Bet(msg.sender, _amount, _betType, _overtime, block.timestamp);
        game.bettors.push(msg.sender);
        game.totalPool += _amount;
        hasBet[msg.sender][_gameId] = true;

        transactionHistory[msg.sender].push(Bet(msg.sender, _amount, _betType, _overtime, block.timestamp));

        emit BetPlaced(msg.sender, _gameId, _amount, _betType, _overtime, block.timestamp);
    }

    function startGame(uint256 _gameId) external {
        Game storage game = games[_gameId];
        require(block.timestamp >= game.startTime, "Game not started yet");
        require(game.isActive, "Game already started or invalid");
        game.isActive = false;
        emit GameStarted(_gameId, game.startTime);
    }

    function completeGame(uint256 _gameId, BetType _result, bool _hadOvertime) external {
        require(msg.sender == owner, "Only owner can complete game");
        Game storage game = games[_gameId];
        require(!game.isActive && !game.completed, "Game not started or already completed");

        game.completed = true;
        game.result = _result;
        game.hadOvertime = _hadOvertime;

        distributeWinnings(_gameId);
        emit GameCompleted(_gameId, _result, _hadOvertime);
    }

    function distributeWinnings(uint256 _gameId) internal {
        Game storage game = games[_gameId];
        uint256 revenueShare = (game.totalPool * 20) / 100;
        uint256 winnerPool = game.totalPool - revenueShare;
        totalRevenue += revenueShare;

        uint256 totalWinningWeight = 0;
        address[] memory winners = new address[](game.bettors.length);
        uint256 winnerCount = 0;

        for (uint256 i = 0; i < game.bettors.length; i++) {
            address bettor = game.bettors[i];
            Bet memory bet = game.bets[bettor];
            bool wonMain = bet.betType == game.result;
            bool wonOvertime = bet.overtime == game.hadOvertime;

            if (wonMain && wonOvertime) {
                totalWinningWeight += bet.amount;
                winners[winnerCount] = bettor;
                winnerCount++;
            }
        }

        for (uint256 i = 0; i < winnerCount; i++) {
            address winner = winners[i];
            Bet memory bet = game.bets[winner];
            uint256 winnerShare = (bet.amount * winnerPool) / totalWinningWeight;
            usdMediator.transferUSD(winner, winnerShare); // Default to Stellar/USD via USDMediator
            transactionHistory[winner].push(Bet(winner, winnerShare, bet.betType, bet.overtime, block.timestamp));
            emit WinningsDistributed(winner, _gameId, winnerShare);
        }
    }

    function withdrawRevenue() external {
        require(msg.sender == owner, "Only owner can withdraw");
        uint256 amount = totalRevenue;
        totalRevenue = 0;
        interoperability.crossChainTransfer(1, 1, "USDC", amount, interoperability.mediatorAccount());
    }

    function getTransactionHistory(address user) external view returns (Bet[] memory) {
        return transactionHistory[user];
    }
}

12. InstilledInteroperability.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./TheGoateToken.sol";

contract InstilledInteroperability {
    address public owner;
    TheGoateToken public goateToken;
    mapping(uint256 => mapping(string => address)) public tokenMap;
    mapping(string => string) public tradingAPIs;
    mapping(string => string) public sportsDataAPIs;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(address _goateToken) {
        owner = msg.sender;
        goateToken = TheGoateToken(_goateToken);
        // Token mappings from provided version
        tokenMap[1]["USDC"] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // Ethereum USDC
        tokenMap[1]["ZPE"] = 0xYourZPEAddress; // Placeholder
        tokenMap[1]["ZPW"] = 0xYourZPWAddress; // Placeholder
        tokenMap[1]["ZPP"] = 0xYourZPPAddress; // Placeholder
        tokenMap[1]["GySt"] = 0xYourGreyStaxAddress; // Placeholder
        tokenMap[512]["XLM"] = 0xYourStellarXLMAddress; // Placeholder
        tokenMap[1]["GOATE"] = _goateToken; // Added Goate Token
        // Trading APIs from provided version
        tradingAPIs["Alpaca"] = "https://api.alpaca.markets";
        tradingAPIs["Tradier"] = "https://api.tradier.com";
        tradingAPIs["SnapTrade"] = "https://api.snaptrade.com";
        tradingAPIs["ETrade"] = "https://api.etrade.com";
        tradingAPIs["TradeStation"] = "https://api.tradestation.com";
        tradingAPIs["Questrade"] = "https://api.questrade.com";
        tradingAPIs["Stellar"] = "https://horizon.stellar.org";
        tradingAPIs["Aquarius"] = "https://api.aquariusdex.com";
        tradingAPIs["MoonPay"] = "https://api.moonpay.com";
        tradingAPIs["1inch"] = "https://api.1inch.exchange/v5.0";
        tradingAPIs["Uniswap"] = "https://api.uniswap.org/v1";
        tradingAPIs["PancakeSwap"] = "https://api.pancakeswap.info/api/v2";
        tradingAPIs["OKX"] = "https://www.okx.com/api/v5";
        tradingAPIs["SushiSwap"] = "https://api.sushiswap.org/v1";
        // Sports Data APIs
        sportsDataAPIs["ESPN"] = "https://api.espn.com";
        sportsDataAPIs["SportsRadar"] = "https://api.sportsradar.com";
    }

    // Add or update a token in the map
    function setToken(uint256 chainId, string memory symbol, address tokenAddress) external onlyOwner {
        tokenMap[chainId][symbol] = tokenAddress;
    }

    // Get sports data API endpoint
    function getSportsDataAPI(string memory apiName) external view returns (string memory) {
        return sportsDataAPIs[apiName];
    }

    // Cross-chain transfer from provided version
    function crossChainTransfer(uint256 fromChain, uint256 toChain, string memory tokenSymbol, uint256 amount, address recipient) external {
        IERC20(tokenMap[fromChain][tokenSymbol]).transferFrom(msg.sender, address(this), amount);
        emit CrossChainTransfer(fromChain, toChain, tokenSymbol, amount, recipient);
    }

    // Mediator account from provided version
    function mediatorAccount() external view returns (address) {
        return 0xYourMediatorAccount; // Placeholder
    }

    event CrossChainTransfer(uint256 fromChain, uint256 toChain, string tokenSymbol, uint256 amount, address recipient);
}


13. Lending.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./USDMediator.sol";
import "./InstilledInteroperability.sol";

contract Lending {
    USDMediator public usdMediator;
    InstilledInteroperability public interoperability;
    address public owner;
    string public plaidAPI = "https://api.plaid.com";

    uint256 public borrowPool;
    mapping(address => uint256) public loans;
    mapping(address => uint256) public loanDueDates;
    mapping(address => uint256) public creditScores;

    string[] public stockList = [
        "WMT", "KMB", "MO", "WPC", "CSCO", "T", "BX", "AAPL", "CAT", "SPG",
        "LMT", "AVY", "MCD", "TGT", "TTWO", "DIS", "BAC", "BBY", "MGY", "NKE"
    ];

    event Lent(address indexed user, uint256 amount);
    event Borrowed(address indexed user, uint256 amount);
    event Repaid(address indexed user, uint256 amount);

    constructor(address _usdMediator, address _interoperability) {
        owner = msg.sender;
        usdMediator = USDMediator(_usdMediator);
        interoperability = InstilledInteroperability(_interoperability);
    }

    function lend(uint256 amount) external {
        require(amount >= 1e6, "Minimum $1 USD");
        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        require(usdc.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        uint256 perStock = amount / 20;
        for (uint256 i = 0; i < stockList.length; i++) {
            usdMediator.buyStock(stockList[i], perStock);
        }
        borrowPool += amount;
        emit Lent(msg.sender, amount);
    }

    function borrow(uint256 amount) external {
        uint256 creditScore = getCreditScore(msg.sender);
        uint256 ecosystemSize = 1000; // Placeholder
        uint256 maxLoan = (creditScore * borrowPool) / (1000 * ecosystemSize);
        require(amount <= maxLoan, "Exceeds loan limit");
        require(loans[msg.sender] == 0, "Existing loan pending");
        require(borrowPool >= amount, "Insufficient pool");

        borrowPool -= amount;
        loans[msg.sender] = amount;
        loanDueDates[msg.sender] = block.timestamp + 30 days;
        usdMediator.transferUSD(msg.sender, amount);
        emit Borrowed(msg.sender, amount);
    }

    function repay(uint256 amount) external {
        require(loans[msg.sender] >= amount, "Invalid amount");
        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        require(usdc.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        loans[msg.sender] -= amount;
        borrowPool += amount;
        if (loans[msg.sender] == 0) loanDueDates[msg.sender] = 0;
        emit Repaid(msg.sender, amount);
    }

    function handleDefault(address user) external {
        require(loanDueDates[user] != 0 && block.timestamp > loanDueDates[user], "Not defaulted");
        uint256 debt = loans[user];
        usdMediator.stakeDebt(user, debt);
        loans[user] = 0;
        loanDueDates[user] = 0;
    }

    function getCreditScore(address user) internal returns (uint256) {
        if (creditScores[user] == 0) {
            creditScores[user] = 700; // Default, updated off-chain via Plaid
        }
        return creditScores[user];
    }
}


14. PityPat.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./USDMediator.sol";

contract PityPat {
    USDMediator public mediator;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(address _mediator) {
        owner = msg.sender;
        mediator = USDMediator(_mediator);
    }

    // Example game function using USDMediator
    function playGame(uint256 betAmount) external {
        require(mediator.usdcToken().transferFrom(msg.sender, address(mediator), betAmount), "Transfer failed");
        // Game logic here
    }
}


15. ScratchOffNFT.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "./USDMediator.sol";
import "./InstilledInteroperability.sol";

contract ScratchOffNFT is ERC721, Ownable, VRFConsumerBase {
    USDMediator public usdMediator;
    InstilledInteroperability public interoperability;
    uint256 public tokenCounter;
    bytes32 internal keyHash;
    uint256 internal fee;

    enum Mode { Pennies, Nickels, Dimes, Quarters, Dollars }
    uint256[] public costs = [
        1e6,   // $1.00 (Pennies)
        5e6,   // $5.00 (Nickels)
        10e6,  // $10.00 (Dimes)
        25e6,  // $25.00 (Quarters)
        100e6  // $100.00 (Dollars)
    ];

    uint256[9][5] public weights = [
        [10, 5, 5, 10, 10, 10, 10, 10, 30],  // Pennies
        [10, 10, 5, 10, 10, 10, 10, 10, 25], // Nickels
        [20, 10, 10, 10, 10, 10, 10, 10, 20], // Dimes
        [20, 10, 10, 10, 10, 15, 10, 10, 15], // Quarters
        [20, 15, 10, 10, 10, 15, 10, 10, 10]  // Dollars
    ];

    string[9] public symbols = [
        "lightning",
        "GoateElectric",
        "zeropointLogo",
        "zeropointWifiLogo",
        "zeropointPhoneServiceLogo",
        "greyStaxLogo",
        "luckCardLogo",
        "karmaCard",
        "gerastyxOpolLogo"
    ];

    struct ScratchCard {
        address owner;
        Mode mode;
        uint256[9] spots;
        bool revealed;
    }

    mapping(uint256 => ScratchCard) public scratchCards;
    mapping(bytes32 => uint256) public requestIdToTokenId;
    mapping(bytes32 => uint256) public requestIdToSpot;

    event ScratchRequested(uint256 tokenId, address user, Mode mode);
    event SpotRevealed(uint256 tokenId, uint256 spot, string symbol);
    event PrizeAwarded(uint256 tokenId, uint256 prize);

    constructor(
        address _usdMediator,
        address _interoperability,
        address _vrfCoordinator,
        address _link,
        bytes32 _keyHash,
        uint256 _fee
    )
        ERC721("ScratchOffNFT", "SONFT")
        Ownable(msg.sender)
        VRFConsumerBase(_vrfCoordinator, _link)
    {
        usdMediator = USDMediator(_usdMediator);
        interoperability = InstilledInteroperability(_interoperability);
        keyHash = _keyHash;
        fee = _fee;
    }

    function scratch(string memory asset, uint256 mode, uint256 chainId) external {
        require(mode <= uint256(Mode.Dollars), "Invalid mode");
        uint256 cost = costs[mode];
        address tokenAddress = interoperability.tokenMap(chainId, asset);
        IERC20 token = IERC20(tokenAddress);
        require(token.transferFrom(msg.sender, address(this), cost), "Transfer failed");

        uint256 half = cost / 2;
        require(token.transfer(address(usdMediator), half), "Mediator transfer failed");
        require(token.transfer(0xYourRevenueAddress, half), "Revenue transfer failed");

        uint256 tokenId = tokenCounter;
        _mint(msg.sender, tokenId);
        scratchCards[tokenId] = ScratchCard(msg.sender, Mode(mode), [0, 0, 0, 0, 0, 0, 0, 0, 0], false);
        tokenCounter++;

        for (uint256 spot = 0; spot < 9; spot++) {
            bytes32 requestId = requestRandomness(keyHash, fee);
            requestIdToTokenId[requestId] = tokenId;
            requestIdToSpot[requestId] = spot;
        }

        emit ScratchRequested(tokenId, msg.sender, Mode(mode));
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        uint256 tokenId = requestIdToTokenId[requestId];
        uint256 spot = requestIdToSpot[requestId];
        ScratchCard storage card = scratchCards[tokenId];
        Mode mode = card.mode;

        uint256 totalWeight = 100;
        uint256 randomValue = randomness % totalWeight;
        uint256 cumulativeWeight = 0;
        for (uint256 i = 0; i < 9; i++) {
            cumulativeWeight += weights[uint256(mode)][i];
            if (randomValue < cumulativeWeight) {
                card.spots[spot] = i;
                emit SpotRevealed(tokenId, spot, symbols[i]);
                break;
            }
        }

        bool allRevealed = true;
        for (uint256 i = 0; i < 9; i++) {
            if (card.spots[i] == 0 && i != spot) {
                allRevealed = false;
                break;
            }
        }

        if (allRevealed && !card.revealed) {
            card.revealed = true;
            uint256 gerastyxCount = 0;
            for (uint256 i = 0; i < 9; i++) {
                if (card.spots[i] == 8) {
                    gerastyxCount++;
                }
            }

            if (gerastyxCount >= 3) {
                uint256 prize = costs[uint256(mode)] * gerastyxCount;
                usdMediator.transferUSD(card.owner, prize);
                emit PrizeAwarded(tokenId, prize);
            }
        }
    }
}

16. Spades.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract Spades is VRFConsumerBase {
    // Constants
    uint8 constant NUM_PLAYERS = 4;
    uint8 constant CARDS_PER_PLAYER = 13;
    uint8 constant TOTAL_CARDS = 52;
    uint256 constant BID_TIMEOUT = 30; // 30 seconds

    // Game state
    address[4] public players;
    uint8 public dealer;
    uint8 public leader;
    uint8 public currentPlayer;
    uint8[4] public tricksWon; // Tricks in current hand
    uint256 public teamAScore; // Team 0 & 2 (in wei, e.g., 4400000 = 4.4)
    uint256 public teamBScore; // Team 1 & 3
    uint8 public teamAStrikes;
    uint8 public teamBStrikes;
    uint8 public teamAReneges;
    uint8 public teamBReneges;
    bool public gameOver;
    mapping(uint8 => uint8[]) public hands;
    uint8[] public currentTrick;
    uint8 public suitLed;
    uint8[2] public teamBids; // Team A (0), Team B (1)
    mapping(uint8 => uint8) public playerBids; // Player index => bid
    uint256 public bidStartTime;
    uint8 public biddingPhase; // 0=dealer, 1=dealer's partner, 2=left, 3=left's partner
    bool public firstRound;

    // Betting
    uint256 public betAmount;
    address public revenueAddress;

    // Chainlink VRF
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 public randomResult;

    // Chainlink Oracle for Time
    AggregatorV3Interface internal timeFeed; // Hypothetical time oracle

    // Events
    event BidPlaced(uint8 indexed player, uint8 bid);
    event TrickWon(uint8 indexed winner, uint8 books);
    event GameEnded(address winnerTeam, uint256 winnings);

    // Constructor
    constructor(
        address[4] memory _players,
        address _vrfCoordinator,
        address _link,
        bytes32 _keyHash,
        uint256 _fee,
        address _timeFeed,
        address _revenueAddress
    ) VRFConsumerBase(_vrfCoordinator, _link) payable {
        players = _players;
        keyHash = _keyHash;
        fee = _fee;
        timeFeed = AggregatorV3Interface(_timeFeed);
        revenueAddress = _revenueAddress;
        betAmount = msg.value / 2; // Split between teams
        dealer = uint8(block.timestamp % 4);
        leader = (dealer + 1) % 4;
        currentPlayer = leader;
        firstRound = true;
        biddingPhase = 0;
    }

    // Start a new hand
    function startNewHand() public {
        require(!gameOver, "Game is over");
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
        requestRandomness(keyHash, fee);
    }

    // Fulfill randomness and deal cards
    function fulfillRandomness(bytes32, uint256 randomness) internal override {
        randomResult = randomness;
        uint8[52] memory deck;
        for (uint8 i = 0; i < 52; i++) deck[i] = i;
        for (uint8 i = 51; i > 0; i--) {
            uint8 j = uint8(uint256(keccak256(abi.encode(randomness, i))) % (i + 1));
            (deck[i], deck[j]) = (deck[j], deck[i]);
        }
        for (uint8 p = 0; p < 4; p++) {
            delete hands[p];
            for (uint8 c = 0; c < 13; c++) {
                hands[p].push(deck[p * 13 + c]);
            }
        }
        resetTrickState();
        bidStartTime = getCurrentTime();
        biddingPhase = 0;
        if (firstRound) {
            teamBids[0] = 4;
            teamBids[1] = 4;
            firstRound = false;
            currentPlayer = leader;
        }
    }

    // Place a bid
    function placeBid(uint8 bid) public {
        require(!firstRound, "First round has fixed bids");
        require(bid <= 13, "Bid must be 0-13");
        require(getCurrentTime() < bidStartTime + BID_TIMEOUT, "Bid timeout");
        require(msg.sender == players[currentBidder()], "Not your turn to bid");

        playerBids[currentBidder()] = bid;
        emit BidPlaced(currentBidder(), bid);

        if (biddingPhase == 0 || biddingPhase == 2) {
            // Wait for partner
            biddingPhase++;
        } else {
            // Calculate team bid
            uint8 teamIndex = (currentBidder() % 2 == 0) ? 0 : 1;
            teamBids[teamIndex] = playerBids[currentBidder()] + playerBids[currentBidder() - 1];
            biddingPhase++;
        }

        if (biddingPhase == 4) {
            biddingPhase = 255; // Bidding done
            currentPlayer = leader;
        }
        bidStartTime = getCurrentTime();
    }

    // Play a card
    function playCard(uint8 card) public {
        require(msg.sender == players[currentPlayer], "Not your turn");
        require(biddingPhase == 255 || firstRound, "Bidding not complete");
        require(isValidPlay(card, currentPlayer), "Invalid play");

        bool reneged = checkRenege(card, currentPlayer);
        if (reneged) {
            uint8 team = (currentPlayer % 2 == 0) ? 0 : 1;
            if (team == 0) teamAReneges++;
            else teamBReneges++;
        }

        removeCardFromHand(currentPlayer, card);
        currentTrick.push(card);

        if (currentTrick.length == 1) suitLed = getSuit(card);
        currentPlayer = (currentPlayer + 1) % 4;

        if (currentTrick.length == 4) {
            resolveTrick();
        }
    }

    // Resolve a trick
    function resolveTrick() internal {
        uint8 winner = determineWinner(currentTrick, suitLed);
        tricksWon[winner]++;
        emit TrickWon(winner, tricksWon[winner]);
        leader = winner;
        currentPlayer = winner;

        if (tricksWon[0] + tricksWon[1] + tricksWon[2] + tricksWon[3] == 13) {
            resolveHand();
        } else {
            resetTrickState();
        }
    }

    // Resolve a hand
    function resolveHand() internal {
        uint8 teamATricks = tricksWon[0] + tricksWon[2];
        uint8 teamBTricks = tricksWon[1] + tricksWon[3];

        // Team A
        if (teamATricks >= teamBids[0]) {
            uint256 excess = teamATricks - teamBids[0];
            teamAScore += (teamBids[0] * 1 ether) + (excess * 1 ether / 10); // e.g., 4.4 = 4400000 wei
        } else {
            teamAStrikes++;
        }

        // Team B
        if (teamBTricks >= teamBids[1]) {
            uint256 excess = teamBTricks - teamBids[1];
            teamBScore += (teamBids[1] * 1 ether) + (excess * 1 ether / 10);
        } else {
            teamBStrikes++;
        }

        checkGameEnd();
        if (!gameOver) {
            dealer = (dealer + 1) % 4;
            leader = (dealer + 1) % 4;
            startNewHand();
        }
    }

    // Check game end conditions
    function checkGameEnd() internal {
        bool teamAWins = teamAScore >= 25 ether;
        bool teamBWins = teamBScore >= 25 ether;
        bool teamALoses = (teamAStrikes >= 3) || (teamAReneges >= 2) || 
                         (teamAStrikes >= 2 && teamAStrikes > tricksWon[0] + tricksWon[2]);
        bool teamBLoses = (teamBStrikes >= 3) || (teamBReneges >= 2) || 
                         (teamBStrikes >= 2 && teamBStrikes > tricksWon[1] + tricksWon[3]);

        if (teamAWins || teamBLoses) {
            gameOver = true;
            payable(players[0]).transfer(betAmount * 2);
            emit GameEnded(players[0], betAmount * 2);
        } else if (teamBWins || teamALoses) {
            gameOver = true;
            payable(players[1]).transfer(betAmount * 2);
            emit GameEnded(players[1], betAmount * 2);
        } else if (teamAReneges > 0 && teamBReneges > 0 && currentTrick.length == 4) {
            gameOver = true;
            payable(revenueAddress).transfer(betAmount * 2);
            emit GameEnded(address(0), 0);
        }
    }

    // Helpers (unchanged from previous unless noted)
    function getSuit(uint8 card) public pure returns (uint8) {
        if (card == 51) return 4; // Little Joker
        if (card == 52) return 4; // Big Joker
        return card / 13;
    }

    function getRank(uint8 card) public pure returns (uint8) {
        if (card == 51) return 13;
        if (card == 52) return 14;
        return card % 13;
    }

    function isValidPlay(uint8 card, uint8 player) public view returns (bool) {
        bool hasCard = false;
        for (uint8 i = 0; i < hands[player].length; i++) {
            if (hands[player][i] == card) {
                hasCard = true;
                break;
            }
        }
        if (!hasCard) return false;
        if (currentTrick.length == 0) return true;
        uint8 playerSuit = getSuit(card);
        if (playerSuit == suitLed) return true;
        for (uint8 i = 0; i < hands[player].length; i++) {
            if (getSuit(hands[player][i]) == suitLed) return false;
        }
        return true;
    }

    function checkRenege(uint8 card, uint8 player) internal view returns (bool) {
        if (currentTrick.length == 0 || getSuit(card) == suitLed) return false;
        for (uint8 i = 0; i < hands[player].length; i++) {
            if (getSuit(hands[player][i]) == suitLed && hands[player][i] != card) {
                return true;
            }
        }
        return false;
    }

    function removeCardFromHand(uint8 player, uint8 card) internal {
        for (uint8 i = 0; i < hands[player].length; i++) {
            if (hands[player][i] == card) {
                hands[player][i] = hands[player][hands[player].length - 1];
                hands[player].pop();
                break;
            }
        }
    }

    function determineWinner(uint8[] memory cards, uint8 suitLed) public pure returns (uint8) {
        uint8 maxIndex = 0;
        bool trumpPlayed = false;
        for (uint8 i = 0; i < 4; i++) {
            uint8 suit = getSuit(cards[i]);
            uint8 rank = getRank(cards[i]);
            if (suit == 4 || suit == 0) { // Joker or spade
                if (!trumpPlayed || compareCards(cards[i], cards[maxIndex]) > 0) {
                    maxIndex = i;
                    trumpPlayed = true;
                }
            } else if (!trumpPlayed && suit == suitLed) {
                if (rank > getRank(cards[maxIndex])) maxIndex = i;
            }
        }
        return maxIndex;
    }

    function compareCards(uint8 card1, uint8 card2) public pure returns (int8) {
        uint8 suit1 = getSuit(card1);
        uint8 suit2 = getSuit(card2);
        uint8 rank1 = getRank(card1);
        uint8 rank2 = getRank(card2);
        if (suit1 == 4 && suit2 != 4) return 1;
        if (suit2 == 4 && suit1 != 4) return -1;
        if (suit1 == 4 && suit2 == 4) return (rank1 > rank2) ? int8(1) : int8(-1);
        if (suit1 == 0 && suit2 != 0) return 1;
        if (suit2 == 0 && suit1 != 0) return -1;
        if (suit1 == 0 && suit2 == 0) return (rank1 > rank2) ? int8(1) : int8(-1);
        return (rank1 > rank2) ? int8(1) : int8(-1);
    }

    function resetTrickState() internal {
        delete currentTrick;
        suitLed = 255;
        for (uint8 p = 0; p < 4; p++) tricksWon[p] = 0;
    }

    function currentBid

17. TheGoateToken.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract TheGoateToken is ERC20, Ownable {
    mapping(address => uint256) public userPrices; // Custom price per user
    mapping(address => uint256) public achievements; // Track user achievements

    event Airdrop(address indexed recipient, uint256 amount);

    constructor() ERC20("The Goate Token", "GOATE") Ownable(msg.sender) {
        _mint(msg.sender, 1000000 * 10**18); // Initial supply: 1M tokens
    }

    // Set custom price for a user
    function setUserPrice(address user, uint256 price) external onlyOwner {
        userPrices[user] = price;
    }

    // Get user's custom price
    function getUserPrice(address user) external view returns (uint256) {
        return userPrices[user] > 0 ? userPrices[user] : 1 * 10**18; // Default price: 1 token
    }

    // Record an achievement and airdrop tokens
    function recordAchievement(address user, uint256 achievementPoints) external onlyOwner {
        achievements[user] += achievementPoints;
        uint256 airdropAmount = achievementPoints * 10 * 10**18; // 10 tokens per point
        _mint(user, airdropAmount);
        emit Airdrop(user, airdropAmount);
    }

    // Override transfer to respect custom pricing (optional logic)
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        return super.transfer(recipient, amount);
    }
}


18. TheLambduckCard.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./InstilledInteroperability.sol";

contract TheLambduckCard {
    InstilledInteroperability public interoperability;
    uint256 public constant DAILY_SPENDING_LIMIT = 10_000_000_000 * 10**18;

    struct User {
        string firstName;
        string lastName;
        bytes32 cardNumberHash;
        uint256[3] cvc;
        uint256 balance; // USDC balance
    }
    mapping(address => User) public users;
    mapping(bytes32 => address) public cardNumberToUser;

    constructor(address _interoperability) {
        interoperability = InstilledInteroperability(_interoperability);
    }

    function registerUser(string memory firstName, string memory lastName) external {
        require(bytes(users[msg.sender].firstName).length == 0, "User already registered");
        uint256[3] memory cvc = [
            uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, 1))) % 1000,
            uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, 2))) % 1000,
            uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, 3))) % 1000
        ];
        bytes32 cardNumberHash = keccak256(abi.encodePacked(msg.sender, block.timestamp));
        users[msg.sender] = User(firstName, lastName, cardNumberHash, cvc, 0);
        cardNumberToUser[cardNumberHash] = msg.sender;
    }

    modifier onlyVerifiedToken(uint256 chainId, string memory tokenSymbol) {
        (, , , address tokenAddress, ,) = interoperability.verifiedTokenAssets(chainId, tokenSymbol);
        require(tokenAddress != address(0), "Asset not available");
        _;
    }

    function buyWithCard(address merchant, uint256 amount, uint256 chainId, string memory tokenSymbol) 
        external onlyVerifiedToken(chainId, tokenSymbol) {
        require(users[msg.sender].balance >= amount, "Insufficient balance");
        require(amount <= DAILY_SPENDING_LIMIT, "Exceeds daily limit");
        users[msg.sender].balance -= amount;
        interoperability.crossChainTransfer(chainId, chainId, tokenSymbol, amount, merchant);
    }

    function withdrawToCard(uint256 amount, uint256 chainId, string memory tokenSymbol) 
        external onlyVerifiedToken(chainId, tokenSymbol) {
        users[msg.sender].balance += amount;
        interoperability.crossChainTransfer(chainId, chainId, tokenSymbol, amount, address(this));
    }

    function withdrawFromCard(address recipient, uint256 amount, uint256 chainId, string memory tokenSymbol) 
        external onlyVerifiedToken(chainId, tokenSymbol) {
        require(users[msg.sender].balance >= amount, "Insufficient balance");
        users[msg.sender].balance -= amount;
        interoperability.crossChainTransfer(chainId, chainId, tokenSymbol, amount, recipient);
    }
}


19. War.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract War is VRFConsumerBase {
    // Constants
    uint8 constant MIN_PLAYERS = 4;
    uint8 constant MAX_PLAYERS = 8;
    uint8 constant TOTAL_CARDS = 52;

    // Game state
    address[] public players;            // List of player addresses
    uint8 public numPlayers;             // Number of players in the session
    uint8 public firstDealer;            // Index of the first player to receive a card
    mapping(address => uint8[]) public hands;  // Each player's hand of cards
    uint8[] public currentRoundCards;    // Cards played in the current round
    uint256 public randomResult;         // Randomness from Chainlink VRF
    bool public gameOver;                // Tracks if the game has ended
    address public winner;               // Winner of the game

    // Chainlink VRF configuration
    bytes32 internal keyHash;
    uint256 internal fee;

    // Events for Unreal Engine integration
    event RoundWinner(address winner, uint8 cardsWon);
    event GameEnded(address winner);

    // Constructor: Initialize players and Chainlink VRF
    constructor(
        address[] memory _players,
        address _vrfCoordinator,
        address _link,
        bytes32 _keyHash,
        uint256 _fee
    ) VRFConsumerBase(_vrfCoordinator, _link) {
        require(_players.length >= MIN_PLAYERS && _players.length <= MAX_PLAYERS, "Invalid number of players");
        players = _players;
        numPlayers = uint8(_players.length);
        keyHash = _keyHash;
        fee = _fee;
        gameOver = false;
    }

    // Start the game by requesting randomness from Chainlink
    function startGame() public {
        require(!gameOver, "Game is over");
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK for VRF");
        requestRandomness(keyHash, fee);
    }

    // Chainlink callback: Use randomness to shuffle and deal cards
    function fulfillRandomness(bytes32, uint256 randomness) internal override {
        randomResult = randomness;

        // Randomly select the first player to receive a card
        firstDealer = uint8(randomness % numPlayers);

        // Initialize the deck (0-51 representing 52 cards)
        uint8[52] memory deck;
        for (uint8 i = 0; i < TOTAL_CARDS; i++) {
            deck[i] = i;
        }

        // Shuffle the deck using Fisher-Yates algorithm (from Spades.sol)
        for (uint8 i = 51; i > 0; i--) {
            uint8 j = uint8(uint256(keccak256(abi.encode(randomness, i))) % (i + 1));
            (deck[i], deck[j]) = (deck[j], deck[i]);
        }

        // Deal cards counterclockwise starting from firstDealer
        uint8 currentPlayer = firstDealer;
        for (uint8 i = 0; i < TOTAL_CARDS; i++) {
            hands[players[currentPlayer]].push(deck[i]);
            currentPlayer = (currentPlayer + numPlayers - 1) % numPlayers; // Counterclockwise
        }
    }

    // Play a round of War
    function playRound() public {
        require(!gameOver, "Game is over");
        require(currentRoundCards.length == 0, "Round already in progress");

        // Each player plays their top card
        for (uint8 i = 0; i < numPlayers; i++) {
            address player = players[i];
            require(hands[player].length > 0, "Player has no cards");
            uint8 card = hands[player][0];
            removeCardFromHand(player, 0);
            currentRoundCards.push(card);
        }

        // Find the highest card and determine the winner(s)
        uint8 highestRank = 0;
        uint8[] memory winners;
        for (uint8 i = 0; i < numPlayers; i++) {
            uint8 rank = getRank(currentRoundCards[i]);
            if (rank > highestRank) {
                highestRank = rank;
                delete winners;
                winners = new uint8[](1);
                winners[0] = i;
            } else if (rank == highestRank) {
                winners.push(i);
            }
        }

        if (winners.length == 1) {
            // Single winner takes all cards
            address roundWinner = players[winners[0]];
            for (uint8 i = 0; i < numPlayers; i++) {
                hands[roundWinner].push(currentRoundCards[i]);
            }
            emit RoundWinner(roundWinner, numPlayers);
        } else {
            // Tie: Trigger a simplified war
            startWar(winners);
        }

        // Clear the round cards
        delete currentRoundCards;

        // Check if the game is over
        for (uint8 i = 0; i < numPlayers; i++) {
            if (hands[players[i]].length == TOTAL_CARDS) {
                gameOver = true;
                winner = players[i];
                emit GameEnded(winner);
                break;
            }
        }
    }

    // Simplified war resolution (random winner for brevity)
    function startWar(uint8[] memory tiedPlayers) internal {
        // In a full implementation, tied players would play additional cards
        // Here, we randomly select a winner among tied players
        uint8 randomIndex = uint8(uint256(keccak256(abi.encode(randomResult, block.timestamp))) % tiedPlayers.length);
        address warWinner = players[tiedPlayers[randomIndex]];
        for (uint8 i = 0; i < numPlayers; i++) {
            hands[warWinner].push(currentRoundCards[i]);
        }
        emit RoundWinner(warWinner, numPlayers);
    }

    // Helper: Get card rank (0=2, ..., 11=King, 12=Ace)
    function getRank(uint8 card) public pure returns (uint8) {
        return card % 13;
    }

    // Helper: Remove a card from a player's hand
    function removeCardFromHand(address player, uint8 index) internal {
        uint8[] storage hand = hands[player];
        require(index < hand.length, "Invalid card index");
        for (uint8 i = index; i < hand.length - 1; i++) {
            hand[i] = hand[i + 1];
        }
        hand.pop();
    }
}


20. Zeropoint.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

// Zeropoint ($ZPE) token for Goate Electric's wireless charging utility
contract Zeropoint is ERC20, Ownable {
    constructor(address initialOwner) ERC20("Zeropoint", "ZPE") Ownable(initialOwner) {
        _mint(initialOwner, 1000000 * 10**3); // Initial supply: 1M $ZPE with 3 decimals
    }

    // Override decimals to 3, reflecting $ZPE's precision (pegged to $0.10)
    function decimals() public view virtual override returns (uint8) {
        return 3;
    }

    // Mint new $ZPE tokens (restricted to owner, e.g., Goate Electric admin)
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    // Burn $ZPE tokens (users can burn their own tokens)
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
}


21. ZeropointDigitalStockNFT.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./USDMediator.sol";
import "./InstilledInteroperability.sol";

contract ZeropointDigitalStockNFT is ERC721, Ownable {
    USDMediator public usdMediator;
    InstilledInteroperability public interoperability;
    uint256 public tokenCounter;
    mapping(uint256 => string) public stockSymbols;
    mapping(uint256 => uint256) public totalInvested;
    mapping(uint256 => mapping(address => uint256)) public userInvestments;
    mapping(uint256 => uint256) public dividendPool;

    event StockPurchased(uint256 tokenId, address buyer, uint256 amount);
    event StockSold(uint256 tokenId, address seller, uint256 amount);
    event DividendDistributed(uint256 tokenId, uint256 amount);

    constructor(address _usdMediator, address _interoperability) ERC721("ZeropointDigitalStockNFT", "ZDSNFT") Ownable(msg.sender) {
        usdMediator = USDMediator(_usdMediator);
        interoperability = InstilledInteroperability(_interoperability);
    }

    function mintStock(address to, string memory stockSymbol) external onlyOwner {
        uint256 tokenId = tokenCounter;
        _mint(to, tokenId);
        stockSymbols[tokenId] = stockSymbol;
        tokenCounter++;
    }

    function buyStock(uint256 tokenId, uint256 amount, uint256 chainId) external {
        require(_exists(tokenId), "Stock does not exist");
        require(amount >= 1e6, "Minimum $1 USD");

        IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        require(usdc.transferFrom(msg.sender, address(usdMediator), amount), "Transfer failed");
        usdMediator.buyStock(stockSymbols[tokenId], amount);

        if (balanceOf(msg.sender) == 0 || ownerOf(tokenId) != msg.sender) {
            _safeTransfer(address(this), msg.sender, tokenId, "");
        }
        totalInvested[tokenId] += amount;
        userInvestments[tokenId][msg.sender] += amount;

        if (chainId != block.chainid) {
            interoperability.crossChainTransfer(block.chainid, chainId, "ZDSNFT", amount, msg.sender);
        }

        emit StockPurchased(tokenId, msg.sender, amount);
    }

    function sellStock(uint256 tokenId, uint256 amount, string memory toAsset, uint256 chainId) external {
        require(ownerOf(tokenId) == msg.sender, "Not owner");
        uint256 userInvestment = userInvestments[tokenId][msg.sender];
        require(amount <= userInvestment, "Insufficient balance");

        uint256 proRata = (userInvestment * 1e18) / totalInvested[tokenId];
        uint256 saleAmount = (proRata * amount) / 1e18;

        usdMediator.sellStock(stockSymbols[tokenId], saleAmount, toAsset, msg.sender);

        totalInvested[tokenId] -= saleAmount;
        userInvestments[tokenId][msg.sender] -= saleAmount;
        if (userInvestments[tokenId][msg.sender] == 0) {
            _safeTransfer(msg.sender, address(this), tokenId, "");
        }

        emit StockSold(tokenId, msg.sender, saleAmount);
    }

    function distributeDividends(uint256 tokenId, uint256 amount) external onlyOwner {
        dividendPool[tokenId] += amount;
        for (uint256 i = 0; i < balanceOf(msg.sender); i++) {
            address holder = ownerOf(tokenId);
            uint256 proRata = (userInvestments[tokenId][holder] * 1e18) / totalInvested[tokenId];
            uint256 dividend = (proRata * amount) / 1e18;
            usdMediator.transferUSD(holder, dividend);
            emit DividendDistributed(tokenId, dividend);
        }
    }
}


22. ZeropointPhoneService.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract ZeropointPhone is ERC20, Ownable {
    uint256 public constant SUBSCRIPTION_COST = 100; // 1 $ZPP = 100 units (2 decimals), $5
    uint256 public constant SUBSCRIPTION_DURATION = 30 days;
    mapping(address => uint256) public lastSubscriptionTime;
    address public revenueRecipient;

    constructor(address initialOwner) ERC20("ZeropointPhone", "ZPP") Ownable(initialOwner) {
        _mint(initialOwner, 1000000 * 10**2); // 1M $ZPP
    }

    function decimals() public view virtual override returns (uint8) {
        return 2;
    }

    function setRevenueRecipient(address recipient) external onlyOwner {
        revenueRecipient = recipient;
    }

    function subscribe() external {
        require(balanceOf(msg.sender) >= SUBSCRIPTION_COST, "Insufficient $ZPP balance");
        require(revenueRecipient != address(0), "Revenue recipient not set");
        _transfer(msg.sender, revenueRecipient, SUBSCRIPTION_COST);
        lastSubscriptionTime[msg.sender] = block.timestamp + SUBSCRIPTION_DURATION;
    }

    function isSubscribed(address user) public view returns (bool) {
        return lastSubscriptionTime[user] > block.timestamp;
    }
}


23. ZeropointWifi.sol -

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

// ZeropointWifi ($ZPW) token for Goate Electric's unlimited WiFi subscription
contract ZeropointWifi is ERC20, Ownable {
    constructor(address initialOwner) ERC20("ZeropointWifi", "ZPW") Ownable(initialOwner) {
        _mint(initialOwner, 1000000 * 10**2); // Initial supply: 1M $ZPW with 2 decimals
    }

    // Override decimals to 2, reflecting $ZPW's precision (pegged to $5)
    function decimals() public view virtual override returns (uint8) {
        return 2;
    }

    // Mint new $ZPW tokens (restricted to owner, e.g., Goate Electric admin)
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    // Burn $ZPW tokens (users can burn their own tokens)
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
}



and add 

1. ZeropointGoateInsurance.sol -


2. ValidationPortal.sol -


3. ZeropointHolographicView.sol -


4. S.H.I.E.L.D.Mode.sol -





make solidity contracts ValidationPortal.sol, ZeropointGoateInsurance, S.H.I.E.L.D.Mode.sol, zeropointHolographicView.sol and integrate them into the layout and existing foundation that I have with Goate Electric; a multi-chain platform that allows people to mix digital utilities with their everyday life;


// everybody has their own insurance pool based on how many ZeropointGoateInsurance ($ZGI)tokens they consumed to their vehicle, house, motorcycle, boat, aircraft, or their identy in the mange devices section along if theyve connected regular mobile devices like phones , watches, airpods, hearing aids, medical equipment, etc. with ZeropointEnergy($ZPE), ZeropointWifi($ZPW), ZeropointPhoneService($ZPP), ZerpointHolographicView ($ZPV) & S.H.I.E.L.D. Mode ($SDM). Integrate all the new contracts but keep the same kyc,/aml, ui/ux, and USDMediator & instilledIneteroperability databases; just add to it.



ZeropointGoate Insurance ($ZGI) {
ZeropointGoateInsurance ($ZGI) = $6 monthly subscription to insurance




when the $5 monthly subscription starts; create a digital card in the ZeropointGoateInsurance Page; kind of like manage devices except its with devices that consumed ZeropointGoateInsurance; 
Have the ZeropointGoateInsurance Page like:
{ 
[description]
[consume $ZGI button, and a consume $ZGI page that lets them choose how many $ZGI to choose; then once they confirm it, and use their pin then let connect their device to insurance for the time being ]
[pay by watching ads,once they click and watch the AdWatch google &| youtube &| pi ads 70% revenue to their ZeropointGoateInsurance balance, 30 % to 1. $XLM (15%), 2. $AQUA (20%), 3. $yXLM (20%), 4. $yBTC (15%), 5. $yUSD (15%), 6. ZeropointDigitalStockNFT => Microstrategy (15%) through instilledInteroperability & the USDMediator accounts; ]

[ insured assets manager:
  [assetInsured information:]
  [asset holder name:] 
  [insurance on or off slider (cant be pressed, here or with zeropointgoateinsurance on the manage devices page; when it's manage on the manage devices page too, then it highlights green.]

[make a claim button] - sends a form with their device information on there, their insurance claim balance, and questions: "what happened ?:", "do you have any pictures ?:" and {give them a page to upload pictures, and documents; quantumProof it and add security defenses so any corrupt assets, files, information, uint, or etc data or storage gets siphoned { all Zeropoint Energy dissolved, ZeropointWifi disconnected, ZeropointPhoneService dsconnected, all assets dissolved, and their page refreshed and updated to all their account balances at 0. and they have to start over with a bad standing. },  "how much of YOUR insurance claim do you want:" and let them put a number within their insurances' available balance;   and then at the bottom have a pay with 1 $ZGI button; that button should have a confirm page and then their pin code; once the $ZGI is sent sell it with USDMediator and InstilledInteroperability; and then send it as stakedInsurance to  1. $XLM (15%), 2. $AQUA (20%), 3. $yXLM (20%), 4. $yBTC (15%), 5. $yUSD (15%), 6. ZeropointDigitalStockNFT => Microstrategy (15%);
] }

their claim information goes to Validation Portal as insuranceClaimInformation: their ID, their face scan while on the form: blur any nudity, and their insuranceClaimInformation; and ask them if that person is was the person on the card; with a yes or no slider that shows yes green and no gray when yes is clicked, and no red with yes gray when no is clicked)
eash insuranceClaim has to get verified by 4 people before it can released into  your account as $USD through InstilledInteroperability and the USDMediator
when they pay for their insurance then $0.25 $ZGI goes to each successful validator in validator portal out of 4 ($1 total), and $5 goes to the USDMediator & InstilledInteroperability as stakedInsurance and goes towards 1. $XLM (15%), 2. $AQUA (20%), 3. $yXLM (20%), 4. $yBTC (15%), 5. $yUSD (15%),  ZeropointDigitalStockNFT  6.Microstrategy (5%); 7.Best Buy (5%) 8. Whole Foods (5%) when their device isn't 
then the money gets deposited into their USD balance when their insurance claim gets atleast 4 yes or 4 no; whichever one hits 4 first is the successful verification;

that's 

ValidationPortal {

  connect them to AdWatch instead of adWatch being its own page still allocate 50% usd to user balance, and 50% to revenue reserve through the USDMediator & InstilledInteroperability
  a validate identity button: connects them to an insurance claim with less than 4 yes or 4 no ( they get $0.25 to their USD balance for each successful verification)
  them goldtap button connected to sites to make money and 50% usd is sent to the user, 50% usd is sent to revenue
  
}
connect youtube, netflix, disney+, peacock, espn,and etc videos, and when it is played, it is a hologram. Have the hologram's initial color be blue; but then ad the spectrum for clear color & distortion. When the color and hologram are playing and moving between pixels; it is a regenerative state; so it won't harm people and is a light. have everything played on-screen and then add a slider so people have the choice for "zeropointHolographicView" to be on or off; when its on on, then on is green and off is grey, when on is off , then off is red and on is gray; make sure holographic view is only used for videos inside the neftlix, disney+, youtube, peacock, hulu, hulu plus, bet, and etc;  or the option on facetime, google meet, zoom, or etc to turn zeropointHolographiczView on or off;


ZeropointHolograpchicView ($ZHV) {
zeropoint + camera( front view) or zeropoint + camera (back view);
create a 3d effect; make the natural color : blue, but then fill in with a color spectrum to follow videos and play animations; Then connect movies, videos, & TV shows from these sites in modules & the search bar; Holographic View is $2 a month subscription;:
flixtor.to,
netflix.com,
peacock.com,
disneyplus.com,
youtube.com,
hulu.com,
huluplus.com,
amazonprime.com,

and make tabs for the 1. Movies, 2. TV Shows, 3. Videos, and then these for each once they hover or click one time; and then two clicks is all of the selected:  1. Most Watched (recently within 3 months), 2. Newest (released) , 3. Most Watched All-time (all-time),
Have the ad-rev go 75% to the USDMediator & InstilledInteroperability, 25% allocated to revenue; 


upgrade TheGoateToken with these features: 1. track how many ads people watch, 2. track how much energy people consume, 3. track people's total number of validation, 4. track how much money people have staked, 5. track how many zeropointWifi they've consumed, 6. track how much zeropointDigitalStock they hold, 7. track how many bets they've made in hometeambets. 8. track how many games of GerastyxOpol they played, 9. track how many lottery tickets they bought, 10. track how many games of War, Pity Pat, and Spades they've played all-together. And track their overall credit score: 1. amount of goate electric's native tokens consumed, 2. amount of money staking, 3. amount of ads watched, 4.   
}

S.H.I.E.L.D Mode turns a phone camera into a weapon for self defense. Every new account gets 1 free $SDM that has no monetary value attached to it. They can't sell swap or use it with anything except to shoot. It will walk them through how to use a weapon and at what times a weapon may be needed. After the warning shot & safety methods each $SDM is $1. When $SDM are shot then 100% of them should go to revenue.
S.H.I.E.L.D. Mode ($SDM) {

zeropoint(gun) = icer;
icer = knockout; 
knockout = 100 $ZP;
so $SDM has to equal $1 one dollar; 

the back-camera becomes a lens and the "shoot picture button" turns red and is a "shoot icer" button. When the person clicks the button, then they can shoot their phone as a safe weapon to neuralize someone. put a warning that the police is warned when multiple stots were fired; when you put your phone in $SDM mode then the back camera is a gun and is also recording; when the icer & recording are both playing at a current timestamp time and more than 5 shots were fired then send the recording footage of 30 second before the shot and 30 seconds after to the validationPortal at the same timestamp just 1 day before with the same hours and time of the day; ask them 1. were shots fired at people: yes or no; if yes then 1a, were the police there ?: yes or no, 1b. should the police be called, yes or no; if yes 1c then have thte USDMediator & InstilledInteroperability call the police at 3 stations using the devices connected in the manage devices section; the one close to the gps, the nearest bordering town, and the nearest bordering town east; 30 minutes before the first timestamp before the validationPortal. "Hello we wanted to report an shooting at { gps address } at the { timestamp of the shooting } reported by 4 validators within Goate Electric's Validation Network, the shooter is now { gps of shooter around 30 minutes before the incident (present)(now) , "gps address of accident" is where it will happen; send a team to intercept and defuse the situation. immediately. this is a message from goate electric's securing humanities intelligence, energy, logistics and defenses (S.H.I.E.L.D) for short") then hangup; call all 3 stations at the same  timestamp; different phones at different locations, from the same starting time of 30 minutes before the time of the self-defense mode activation"  "  add a " validate icer self-defense" and when the 4 successful circumstances are found then pay them $0.25 $USD from the revenue reserves with the USDMediator and InstilledInteroperability; ask the participan

}
